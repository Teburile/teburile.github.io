<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>OOP期末复习</title><meta name="description" content="For a New Life"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/image/favicon2.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="期末复习参考www.cplusplus.com
大纲：

类、对象
组合、继承
虚函数、多态
模范、泛型编程
设计模式

命令行
编译器指令
编译链接只编译 1. g++ -c main.cpp -o main.o  g++ -c one.cpp -o one.o
链接 g++ main.o one.o -o main.cpp
头文件只编译一次： #pragma once 
函数声明：
int add(int a,int b);
extern int a;
extern int arr[100];

宏定义及使用 宏替换时一一替换
宏定义可以用于Debug的输出
make工具其中可以定义变量，可以使用BASH语法
命令行参数通过 argc argv 传入
argc是参数的个数，包含程序名称
argv是参数数.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Teburile's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">OOP期末复习</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0"><span class="toc-text">期末复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="toc-text">编译链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%B7%A5%E5%85%B7"><span class="toc-text">make工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">GDB调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">decltype 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For%E5%BE%AA%E7%8E%AF"><span class="toc-text">For循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84"><span class="toc-text">构造、析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text">友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E3%80%81%E5%B8%B8"><span class="toc-text">静态、常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-text">指针析构问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text">移动和右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-text">移动构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="toc-text">自动转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">组合与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E9%9A%90%E8%97%8F"><span class="toc-text">重写隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">向上类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">向下类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">类模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%88%9D%E6%AD%A5"><span class="toc-text">STL初步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-text">容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#function%E7%B1%BB"><span class="toc-text">function类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">迭代器模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%A7%94%E6%89%98"><span class="toc-text">代理委托</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">装饰器</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/OOP"><i class="tag post-item-tag">OOP</i></a><a href="/tags/notes"><i class="tag post-item-tag">notes</i></a><a href="/tags/review"><i class="tag post-item-tag">review</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">OOP期末复习</h1><time class="has-text-grey" datetime="2021-06-11T04:00:00.000Z">2021-06-11</time><article class="mt-2 post-content"><h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><p>参考<a target="_blank" rel="noopener" href="http://www.cplusplus.com/">www.cplusplus.com</a></p>
<p>大纲：</p>
<ol>
<li>类、对象</li>
<li>组合、继承</li>
<li>虚函数、多态</li>
<li>模范、泛型编程</li>
<li>设计模式</li>
</ol>
<p>命令行</p>
<p>编译器指令</p>
<h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><p>只编译 1. g++ -c main.cpp -o main.o  g++ -c one.cpp -o one.o</p>
<p>链接 g++ main.o one.o -o main.cpp</p>
<p>头文件只编译一次： #pragma once </p>
<p>函数声明：</p>
<pre><code class="c++">int add(int a,int b);
extern int a;
extern int arr[100];
</code></pre>
<p>宏定义及使用 宏替换时一一替换</p>
<p>宏定义可以用于Debug的输出</p>
<h3 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h3><p>其中可以定义变量，可以使用BASH语法</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通过 argc argv 传入</p>
<p>argc是参数的个数，包含程序名称</p>
<p>argv是参数数组，0号位是程序名称</p>
<h3 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h3><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>返回类型、名称相同，参数类型不同</p>
<p>在没有对应参数类型的调用时，会自动转换类型</p>
<p>缺省值（默认值），缺省值必须时最后的参数</p>
<h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>自动确定类型，需要在编译器就能够确定类型。</p>
<p>用于取代冗长的变量类型。</p>
<p>声明依赖模板参数的变量类型。</p>
<p>c++14 中，auto可以直接自动推导返回值类型</p>
<h3 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a>decltype 关键字</h3><p>对变量、表达式的类型进行推导，也可以重用没有名字的变量类型。</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><pre><code class="c++">delete ptr;//删除指针指向的单个内存
delete[] array;//删除多个单元组成的内存块
</code></pre>
<p>使用零指针时，注意会不会是0，可能被当成0（在函数重载时），使用nullptr作为真正的零指针</p>
<h3 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h3><pre><code class="c++">//基于范围的循环
for(auto e:array);
cout&lt;&lt;e;
</code></pre>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>权限分组：private protected public</p>
<p>调用：</p>
<ol>
<li>对象名.成员名</li>
<li>对象指针-&gt;成员名</li>
</ol>
<p>所有成员函数的参数当中有一个指向当前对象的指针this</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><pre><code class="c++">inline int max(int a,int b)&#123;
    return a&gt;b?a:b;
&#125;
</code></pre>
<p>内联关键词为 inline</p>
<p>与宏定义相比，编译器自己操作的内联函数不会有代换时的歧义，并且可以正常进行调试</p>
<p>注意：</p>
<ol>
<li>避免堆复杂结构使用内联，否则每个地方复制一份会比较臃肿</li>
<li>内联函数的实现要和声明放在一起，才能够正确内联</li>
<li>内敛修饰符是建议，不是命令，编译器会自己判断</li>
</ol>
<h3 id="构造、析构"><a href="#构造、析构" class="headerlink" title="构造、析构"></a>构造、析构</h3><p>构造函数：</p>
<ul>
<li>可以重载</li>
<li>可以使用初始化列表，数据成员（初始值），按照不同数据成员的声明顺序来初始化</li>
<li>初始化列表当中也可以调用其他<strong>构造函数</strong></li>
<li>C++11后成员变量可以就地初始化</li>
<li>存在其他构造函数时，不会合成默认构造函数，可以使用下述代码复用</li>
</ul>
<pre><code class="c++">A()=default;
A(int a)=delete;//禁止某个构造函数
</code></pre>
<p>析构：</p>
<ul>
<li>编译器自动调用</li>
<li>编译器会自动合成默认析构函数</li>
</ul>
<p>全局对象：</p>
<ol>
<li>构造：发生在main()之前，同一文件中按定义顺序初始化，不同文件中不确定</li>
<li>main()return之后被析构</li>
<li>尽量少用全局对象</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用必须在定义时初始化，不能更改指向</p>
<p>返回值可以是引用，但不能指向临时变量</p>
<p><strong>引用存在的主要意义是为运算符重载提供便利</strong></p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>函数名称为operetor+或者其他运算符即可，参数可以确定或者更改，不再赘述</p>
<p>大部分运算符都可以重载，自创的诡异运算符不行（毕竟运算符重载是为了实现多态）</p>
<p>注：</p>
<ol>
<li>前缀++不需要参数，后缀++需要一个哑元dummy，在使用时，前缀表示，先++在运算，后缀表示先运算再++</li>
<li>小括号重载注意参数要再写一个小括号</li>
<li>= [] () -&gt; 四个运算符只能通过成员函数来重载</li>
<li>流重载，在修改流的情况下，只能够使用全局函数重载</li>
</ol>
<pre><code class="c++">ostream&amp; operator&lt;&lt;(ostream&amp; out,const A&amp; a)&#123;
    out&lt;&lt;a.data;
    return out;
&#125;
</code></pre>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元的声明只能在类内，使用friend关键字，友元可以是类、函数，友元可以访问类内的一切成员</p>
<p>注：友元不能继承，声明友元类时，该类应该已经被声明</p>
<h3 id="静态、常"><a href="#静态、常" class="headerlink" title="静态、常"></a>静态、常</h3><p>静态：static修饰，只能够用于其声明的文件内部</p>
<p>静态数据成员：</p>
<ul>
<li>由所有成员共享，可以通过类名，也可以通过对象来访问</li>
<li>需要在实现文件当中赋值</li>
</ul>
<p>静态成员函数：</p>
<ul>
<li>对函数进行static关键字修饰</li>
<li>只能访问静态成员变量</li>
</ul>
<p>常量：const关键字修饰</p>
<p>常量数据成员：</p>
<ul>
<li>每个对象各有一份</li>
<li>初始化方式限制：<ul>
<li>初始化列表</li>
<li>就地初始化</li>
<li><strong>禁止</strong>在构造函数体内初始化</li>
</ul>
</li>
</ul>
<p>常量成员函数：</p>
<ul>
<li>使用const修饰</li>
<li>只能够进行一些外部操作，不能对对象内部数据进行修改</li>
</ul>
<p>常量对象：不能更改自身，只能够通过常量成员函数进行一些对外的操作</p>
<p>常量静态变量：</p>
<ul>
<li>需要在类外进行定义：<ul>
<li>int和enum类型可以就地初始化</li>
</ul>
</li>
</ul>
<p>静态全局对象：限制全局对象的作用域只在本文件中（全局对象作用域是整个程序）</p>
<p>静态局部对象：起到全局对象的作用，将局部对象的生命周期延长到整个程序</p>
<h3 id="指针析构问题"><a href="#指针析构问题" class="headerlink" title="指针析构问题"></a>指针析构问题</h3><p>对象中含有指针成员时，可能会RE</p>
<p>主要问题在于，调用以对象作为参数的函数时，会复制一份该指针，函数结束后，复制的对象删除，指针也随之删除，原对象再次删除时会RE</p>
<p>解决办法：将上述函数参数改为对象指针或引用</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>使用情况：</p>
<ol>
<li>以一个对象定义另外一个对象</li>
<li>函数调用时以类的对象为形参</li>
<li>函数返回类对象</li>
</ol>
<p>结果：得到一个新对象，与原来相同</p>
<p>定义方式：按构造函数定义，函数参数改为类的常量对象，拷贝构造函数效率与构造函数差不多。</p>
<p>该构造函数内不需要语句进行赋值，赋值工作会自动完成。</p>
<p>拷贝赋值运算，即正常的等号赋值，类似于拷贝构造，只是在已有对象内操作。</p>
<p>拷贝构造函数和拷贝赋值运算在缺失时会被编译器自动合成。</p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h4 id="移动和右值"><a href="#移动和右值" class="headerlink" title="移动和右值"></a>移动和右值</h4><p>右值引用：引用常量、表达式、函数返回值</p>
<p>注：右值引用本身是左值即</p>
<pre><code class="c++">int &amp;&amp;e=1+2;
int &amp;a=e;
cout&lt;&lt;a;//输出3
</code></pre>
<p>右值引用可以实现内存名的改变，称为移动</p>
<p>即，原来地址a存放变量x，值为1，用move配合右值引用后，x可以改名为y，x本身失去意义。</p>
<p>移动发生后，被移动的量失效。</p>
<h4 id="移动构造函数-1"><a href="#移动构造函数-1" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>将构造函数的参数改为右值引用的对象即可，亦不需要手动添加赋值语句。</p>
<p>在调用时，需要右值的参数，可以使用move语句将左值转换为右值，或者原本就是右值。</p>
<p>移动赋值运算，对等号实现移动构造的效果。</p>
<p>移动的操作（包括移动构造和移动赋值）需要手动定义。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>定义运算符：</p>
<ol>
<li>在被转换类中定义运算符，不需要指定类型</li>
<li>在目标类中，定义以被转换类作为参数的构造函数</li>
</ol>
<p>自动转换的分类：</p>
<ol>
<li>显示转换，即直接调用上述转换函数</li>
<li>隐式转换，即在其他函数调用时，参数类型不对，例如把int塞给了以float类型为参数的函数</li>
</ol>
<p>在转换函数前添加explicit关键字可以禁止隐式转换</p>
<pre><code class="c++">explicit operator Dst()&#123;
    ;
&#125;
explicit Dst(const Src &amp;s)&#123;
    ;
&#125;
</code></pre>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>const_cast</p>
<p>static_cast</p>
<p>dynamic_cast</p>
<p>reinterpret_cast</p>
<p>具体如何使用，未讲解 </p>
<h3 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h3><p>组合：将其他类作为数据成员，在初始化其他类时，需要在初始化列表中进行</p>
<p>继承：从一个类派生出新的类，继承也有权限关系，继承成员数据和大部分成员函数，构造、析构、赋值运算符以及友元不继承</p>
<p>派生类的构造：</p>
<ul>
<li>继承来的数据需要调用基类的构造函数，可以让编译器自动调用，也可以手动调用（必须在初始化列表中调用）</li>
<li>可以使用using Base::Base 来复用基类的构造函数，在使用时视为派生类的构造函数，这种用法会把所有基类的构造函数重载全部复用</li>
</ul>
<p>继承时的权限取交集，越来越小</p>
<h3 id="重写隐藏"><a href="#重写隐藏" class="headerlink" title="重写隐藏"></a>重写隐藏</h3><p>在派生类当中定义重名函数，屏蔽掉基类当中所有的同名（不论参数类型）函数，使用using关键字可以恢复使用</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>可能会有部分变量重名，在调用时，在变量名前添加来源类名进行限制</p>
<h3 id="向上类型转换"><a href="#向上类型转换" class="headerlink" title="向上类型转换"></a>向上类型转换</h3><p>将派生类的对象、引用、指针转换为基类的对象、引用指针，为了封装的完整性，只对public继承有效</p>
<ol>
<li>对象的向上类型转换：发生切片，丢失数据和方法</li>
<li>指针和引用的转换，不会丢失原来对象的数据，但是只能够访问基类部分的数据和服务</li>
<li>若要使得基类指针能够访问派生类数据、功能，需要在基类当中将该函数实现为虚函数，使用virtual关键字（实际实现是构建出一个虚函数表，每一个类有一个表，每一个对象有一个指向它的指针）</li>
<li>构造函数不能也不必是虚函数</li>
<li>析构函数最好实现为虚函数，可以精准删除对象的指针</li>
<li>虚函数只需要在基类中添加关键字即可</li>
<li>override关键字：命令编译器检查基类中是否有对应虚函数的存在，使得能够重写成功</li>
<li>final关键字：禁止后续的重写；禁止后续类的继承（即不允许继承当前类）</li>
</ol>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><pre><code class="c++">virtual int func(int a)=0;
</code></pre>
<ul>
<li>包含纯虚函数的类（称为抽象类）不能够定义对象，存在的作用是作为基类统一接口，作为多态的操作窗</li>
<li>抽象类派生类必须重写所有虚函数</li>
<li>纯虚函数能够防止对象的向上类型转换，只允许指针和引用的这种操作</li>
</ul>
<p>向上类型转换可以直接使用基类的指针或引用进行new操作</p>
<h3 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h3><p>将基类指针转化为派生类，进而使用派生类的特性：</p>
<ol>
<li><p>dynamic_cast</p>
<pre><code class="c++">T2* p=dynamic_cast&lt;T2*&gt;(base);
T2&amp; r=dynamic_cast&lt;T2&amp;&gt;(baser);
</code></pre>
<p> 在失败时，指针会返回空指针，而引用会抛出bad_cast异常</p>
<p> 耗时比较久</p>
</li>
<li><p>static_cast</p>
<p>用法与dynamic_cast相同，关键字更改即可。在转换时不会检查类型，直接转换，可能出现问题，但节约时间开销</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>通过向上/下类型转换、虚函数、指针、模板可以实现多态，提高可复用性</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>注：模板必须在头文件中实现，不能够声明和实现分开</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>在函数前添加模板关键字</p>
<pre><code class="c++">template&lt;class T&gt;
T sum(T a, T b)&#123;
    return a+b;
&#125;
</code></pre>
<p>函数模板在调用时，编译器可以自动推导出实际类型，而不需要添加关键字</p>
<p>注：模板的错误会有巨量报错，只看最上方几行</p>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板中除了类型参数外，还可以有其他非类型参数</p>
<pre><code class="c++">template &lt;class T,unsigned size&gt;
class array&#123;
    T ele[size];
&#125;;
</code></pre>
<p>非类型参数可以是整数、枚举、指针、引用、无符号整数(unsigned)</p>
<p>在使用模板构造类时，不能够使用变量作为非类型参数的实参</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>定义命名空间：</p>
<pre><code class="c++">namespace A&#123;
    int x,y;
&#125;
</code></pre>
<p>使用using关键字进行使用</p>
<h3 id="STL初步"><a href="#STL初步" class="headerlink" title="STL初步"></a>STL初步</h3><p>分为两类：container algorithm</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ol>
<li><p>pair:</p>
<ol>
<li>通过first、second两个成员变量获得数据</li>
<li>创建：make_pair(a,b)</li>
<li>支持比较，先比较第一个，再比较第二个</li>
<li>在map中常用</li>
</ol>
</li>
<li><p>tuple：</p>
</li>
<li><p>vector:</p>
<ol>
<li><p>允许下标访问</p>
</li>
<li><p>末尾添加/删除：</p>
<ol>
<li>x.push_back()</li>
<li>x.pop_back()</li>
</ol>
</li>
<li><p>有迭代器</p>
</li>
<li><p>for遍历</p>
<p>for(auto x:vec)</p>
</li>
<li><p>当下迭代器失效</p>
</li>
</ol>
</li>
<li><p>list</p>
<ol>
<li>不支持下标</li>
<li>基本操作与vector类似</li>
</ol>
</li>
<li><p>set</p>
</li>
<li><p>map</p>
</li>
</ol>
<p>选择合适的容器</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>STL提供了方便的string类型</p>
<p>string可以通过加法实现拼接，也能够使用COUT输出</p>
<pre><code class="c++">string s0(s1,3,4);//从s1角标3开始，长度为4
string s2(10.&#39;aa&#39;);//复制字符aa一共10次
str.size();//查询长度
str.length();//查询长度
str.clear();//清空
str.empty();//检查是否为空
str.push_back(&#39;a&#39;);//末尾加入
str.append(s0);//扩展
getline(cin,s0,&#39;s&#39;);//读入存放在s0，以s作为分隔符
//加法实现拼接
//字典序比较大小
int a=stoi(a);//可以转换类型
string a =to_string(1);
</code></pre>
<h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>控制格式</p>
<pre><code class="c++">cout &lt;&lt; fixed &lt;&lt; 2018.0 &lt;&lt; &quot; &quot; &lt;&lt; 0.0001 &lt;&lt; endl;
                //浮点数 -&gt; 2018.000000 0.000100
cout &lt;&lt; scientific &lt;&lt; 2018.0 &lt;&lt; &quot; &quot; &lt;&lt; 0.0001 &lt;&lt; endl;
                //科学计数法 -&gt; 2.018000e+03 1.000000e-04
cout &lt;&lt; defaultfloat;  //还原默认输出格式
cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl;
                //输出精度设置为2 -&gt; 3.2
cout &lt;&lt; oct &lt;&lt; 12 &lt;&lt; &quot; &quot; &lt;&lt; hex &lt;&lt; 12 &lt;&lt; endl; 
                //八进制输出 -&gt; 14  十六进制输出 -&gt; c
cout &lt;&lt; dec;    //还原十进制
cout &lt;&lt; setw(3) &lt;&lt; setfill(&#39;*&#39;) &lt;&lt; 5 &lt;&lt; endl;
                //设置对齐长度为3，对齐字符为* -&gt; **5
</code></pre>
<p>每次更改后记得还原</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>&lt;regex&gt;库</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数指针：</p>
<pre><code class="c++">void (*func)(int&amp;);//指针的声明
//包括返回值，*，变量名，参数列表
//可以使用auto确定
auto func=a&gt;b?func1:func2;
</code></pre>
<p>使用：</p>
<ol>
<li>std::sort自定义</li>
</ol>
<pre><code class="c++">bool compare(int a,int b)&#123;
    return a&gt;b;
&#125;
int main()&#123;
    int array[100];
    int i=0;
    while(i&lt;100)&#123;
        cin&gt;&gt;array[i];
        i++;
    &#125;
    sort(array,array+100,compare);
    return 0;
&#125;
</code></pre>
<p>STL中的函数对象：</p>
<ol>
<li>greater&lt;int&gt;() 返回a&gt;b</li>
<li>less&lt;int&gt;() 返回a&lt;b</li>
</ol>
<p><strong>如何定义函数对象</strong></p>
<ol>
<li>需要重载（）运算符</li>
<li>括号访问权限为public</li>
</ol>
<p>使用时只需要像函数一样使用就可以，记得带小括号</p>
<pre><code class="c++">class Comp&#123;
public:
    bool operator()(int a,int b)const&#123;
        return a&gt;b;
    &#125;
&#125;;
Comp()(1,2);//输出0
</code></pre>
<h4 id="function类"><a href="#function类" class="headerlink" title="function类"></a>function类</h4><p>来自于&lt;functional&gt;头文件，为函数指针和对象提供了统一的接口</p>
<p>可以兼容普通函数以及函数对象</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>来自于&lt;memory&gt;头文件</p>
<pre><code class="c++">shared_ptr&lt;int&gt; p1(new int(1));
//从一个普通的裸指针进行构造
//各种操作（取*取成员函数）如同普通指针
p1.get();//获取裸指针
p1.reset();//清除指针并且减少引用计数
</code></pre>
<p>两个智能指针互相引用时，可能不会自动销毁，造成内存泄漏。</p>
<p>可以使用弱引用来改善</p>
<pre><code class="c++">weak_ptr&lt;int&gt; i;//弱引用指向对象但不计数
//弱引用指针需要从智能指针获得
weak_ptr&lt;int&gt; wp1=p1;
wp.use_count();//获取引用计数
wp.reset();//清除指针
wp.expired();//检查对象是否无效
sp=wp.lock();//弱转智能
</code></pre>
<p>unique_ptr：保证一个对象只被一个指针指向</p>
<pre><code class="c++">auto up1=make_unique&lt;int&gt;(2);//构造
unique_ptr&lt;int&gt; up2=move(up1);//移动，不能复制
int *p=up2.release();//释放，获得裸指针
</code></pre>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>行为型模式有三种：</p>
<ol>
<li>模板方法模式</li>
<li>策略模式</li>
<li>迭代器模式</li>
</ol>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义算法的骨架，可变部分调用其他函数来完成</p>
<p>骨架在基类当中完成，其他函数通过派生出相应的派生类来完成，使用向下类型的指针实现多态。</p>
<p>将可变部分定义为虚函数即可</p>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>定义一系列算法类并加以封装，作为算法骨架类构造函数的参数来完成组合拼装</p>
<p>细节操作上，每一种算法有一个抽象接口类，不同实现有不同的派生类，使用时，将派生类向下转换为基类的指针，用来构造出整个算法</p>
<p>可以降低代码冗余，但是封装性比较差</p>
<p><strong>模板方法和策略模式都是实现某一算法多态时的设计模式，具体实现依赖于算法步骤的切割</strong></p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>将一组数据聚合为一个整体，提供一个统一的接口</p>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p>结构型设计模式三类：</p>
<ol>
<li>适配器</li>
<li>委托/代理模式</li>
<li>装饰器模式</li>
</ol>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>进行接口的转换，对不同的类实现兼容</p>
<p>实现手法：private继承或是组合</p>
<h5 id="代理委托"><a href="#代理委托" class="headerlink" title="代理委托"></a>代理委托</h5><p>在被访问对象上添加一个访问层，类似于中介，同时可以进行新的控制操作</p>
<p>通常的实现操作，代理类继承原有类，且包含一个原有类的子对象</p>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>在原类之外构建一个装饰品大类，之后构造每个细节的装饰品类（继承自装饰品类），在每个类当中都能包含一个指向实际内容的指针即可。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/08/05/note_of_summer_trainning/" title="三系暑培笔记"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 三系暑培笔记</span></a><a class="button is-default" href="/2021/06/06/%E7%89%A9%E7%90%86%E4%B8%8E%E8%AF%97%E4%B9%A6%E6%9B%B2%E8%AF%9D/" title="物理与诗书曲画"><span class="has-text-weight-semibold">下一页: 物理与诗书曲画</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Teburile/blog-comments" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Teburile"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright © </span><span> Teburile 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>