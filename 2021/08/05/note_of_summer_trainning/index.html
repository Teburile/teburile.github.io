<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>三系暑培笔记</title><meta name="description" content="For a New Life"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/image/favicon2.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="[TOC]
概论C#与.netC#：编译产生微软中间语言（MSIL）而非直接由OS执行的机器码
.net框架：将C#编译产生的微软中间语言翻译成为可以让OS执行的机器语言，作为交互媒介
CLR（公共语言运行库）：是.net框架的核心，作为与程序员交互的平台，不需要再深究内存分配与释放的问题
通过CLR的操作系统适配，使得MSIL能够跨平台
.net有很多的版本
.net的版本最初的版本：.net framework 不能跨平台（民间产出了类似的的跨平台CLR Mono）
后来版 .net core 可以跨平台
当core功能齐全之后，改名为.net 5
为了统一.net运行时的标准，微软产出了.net standard
C#排行榜上万年老五，运行在.net上，语法丰富，代码量少
桌面开发(GUI开发类似于Q.."><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Teburile's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">三系暑培笔记</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-text">概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8E-net"><span class="toc-text">C#与.net</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">.net的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C"><span class="toc-text">C#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%AB%99"><span class="toc-text">网站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker"><span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-TypeScript-NodeJs"><span class="toc-text">JavaScript TypeScript NodeJs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="toc-text">React开发框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-Hasura"><span class="toc-text">数据库 Hasura</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E6%A8%A1%E5%9E%8B"><span class="toc-text">OSI模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91"><span class="toc-text">Web全栈开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pytorch"><span class="toc-text">pytorch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arduino"><span class="toc-text">Arduino</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Verilog"><span class="toc-text">Verilog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Latex"><span class="toc-text">Latex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-text">git</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINUX"><span class="toc-text">LINUX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F"><span class="toc-text">什么是程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">什么是操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E3%80%81%E8%B7%AF%E5%BE%84"><span class="toc-text">文件、路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text">命令行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E5%92%8CSHELL"><span class="toc-text">终端和SHELL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BB%A5sh%E4%BD%9C%E4%B8%BA%E5%90%8E%E7%BC%80%E5%90%8D%EF%BC%89"><span class="toc-text">shell脚本（以sh作为后缀名）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">shell配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8EGUI"><span class="toc-text">命令行与GUI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E5%8E%86%E5%8F%B2"><span class="toc-text">linux历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINUX%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">LINUX文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%89%8Blinux"><span class="toc-text">上手linux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSL"><span class="toc-text">WSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker"><span class="toc-text">docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh%E9%85%8D%E7%BD%AE"><span class="toc-text">ssh配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">云端服务器的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2"><span class="toc-text">网站部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%8F%AF%E4%BB%A5%E4%BA%A4%E4%BA%92%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F"><span class="toc-text">部署可以交互的小游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tmux"><span class="toc-text">tmux</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GIT"><span class="toc-text">GIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GITHUB-ACTION"><span class="toc-text">GITHUB ACTION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CI"><span class="toc-text">CI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linter"><span class="toc-text">Linter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试以及集成测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA"><span class="toc-text">构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-1"><span class="toc-text">C#</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%85%A5%E9%97%A8"><span class="toc-text">C#入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5"><span class="toc-text">C#面向对象初步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%97%E6%AE%B5"><span class="toc-text">只读字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#is-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">is 运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-text">委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%B8%BA%E7%A9%BA%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">可为空的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">托管与垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">多线程与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">多线程编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="toc-text">进程间通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8E%9F%E8%AF%AD%EF%BC%89"><span class="toc-text">原子操作（原语）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">互斥量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">c#的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98"><span class="toc-text">其他经典IPC问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TASK"><span class="toc-text">TASK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Winform"><span class="toc-text">Winform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80"><span class="toc-text">布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-1"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE"><span class="toc-text">绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%A9%E7%8E%A9%E5%B0%B1%E5%A5%BD%EF%BC%8C%E4%B8%8D%E5%A4%AA%E5%A5%BD%E7%94%A8"><span class="toc-text">玩玩就好，不太好用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF"><span class="toc-text">WPF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80-1"><span class="toc-text">布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%EF%BC%88control%EF%BC%89"><span class="toc-text">控件（control）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-text">样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-text">绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prism"><span class="toc-text">prism</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-TS-yarn-NodeJS"><span class="toc-text">JS TS yarn NodeJS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js"><span class="toc-text">js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3MDN"><span class="toc-text">文档MDN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-yarn"><span class="toc-text">npm yarn</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8html%E4%B8%AD%E5%BA%94%E7%94%A8css%E5%92%8Cjs"><span class="toc-text">在html中应用css和js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">CSS盒模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80"><span class="toc-text">爬虫基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-TS%E5%AE%9E%E7%8E%B0%E4%BA%A4%E4%BA%92"><span class="toc-text">JS TS实现交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SCSS-Sass"><span class="toc-text">SCSS&#x2F;Sass</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">前端设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">平面设计基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E4%BA%A4%E4%BA%92"><span class="toc-text">界面交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E8%AE%A4%E7%9F%A5"><span class="toc-text">交互认知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack"><span class="toc-text">Webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express-%E5%90%8E%E7%AB%AF"><span class="toc-text">express 后端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-HTTP%E8%AF%B7%E6%B1%82"><span class="toc-text">API HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">中间件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React"><span class="toc-text">React</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-js"><span class="toc-text">Vue.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">单文件组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nuxt-js"><span class="toc-text">Nuxt.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hasura"><span class="toc-text">Hasura</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/note"><i class="tag post-item-tag">note</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">三系暑培笔记</h1><time class="has-text-grey" datetime="2021-08-05T04:00:00.000Z">2021-08-05</time><article class="mt-2 post-content"><p>[TOC]</p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="C-与-net"><a href="#C-与-net" class="headerlink" title="C#与.net"></a>C#与.net</h3><p>C#：编译产生微软中间语言（MSIL）而非直接由OS执行的机器码</p>
<p>.net框架：将C#编译产生的微软中间语言翻译成为可以让OS执行的机器语言，作为交互媒介</p>
<p>CLR（公共语言运行库）：是.net框架的核心，作为与程序员交互的平台，不需要再深究内存分配与释放的问题</p>
<p>通过CLR的操作系统适配，使得MSIL能够跨平台</p>
<p>.net有很多的版本</p>
<h3 id="net的版本"><a href="#net的版本" class="headerlink" title=".net的版本"></a>.net的版本</h3><p>最初的版本：.net framework 不能跨平台（民间产出了类似的的跨平台CLR Mono）</p>
<p>后来版 .net core 可以跨平台</p>
<p>当core功能齐全之后，改名为.net 5</p>
<p>为了统一.net运行时的标准，微软产出了.net standard</p>
<h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><p>排行榜上万年老五，运行在.net上，语法丰富，代码量少</p>
<p>桌面开发(GUI开发类似于QT)：Winform, WPF</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程产生的资源竞争的问题</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>HTML(标记语言描述网页的元素)</p>
<p>CSS 如何装饰HTML</p>
<p>JavaScript添加动态功能</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>核心概念是：镜像（和容器相似，但不能操作）、容器（一种进程，被隔离的进程）、仓库</p>
<p>镜像与容器类似于C++类和对象的关系</p>
<p>docker可以把应用及其依赖的环境打包成一个镜像，来直接部署，用镜像生成一个容器，可以节省配置环境的工作</p>
<h3 id="JavaScript-TypeScript-NodeJs"><a href="#JavaScript-TypeScript-NodeJs" class="headerlink" title="JavaScript TypeScript NodeJs"></a>JavaScript TypeScript NodeJs</h3><p>Js与java无关，与python更为相似</p>
<p>js是一种动态类型的解释性的脚本语言</p>
<p>ECMA是JS的一个标准</p>
<p>TypeScript是JS的超集，提供了固定类型</p>
<p>NodeJs是JS的一个非浏览器运行环境</p>
<p>npm yarn是包管理工具</p>
<h3 id="React开发框架"><a href="#React开发框架" class="headerlink" title="React开发框架"></a>React开发框架</h3><p>用来搭建前端</p>
<h3 id="数据库-Hasura"><a href="#数据库-Hasura" class="headerlink" title="数据库 Hasura"></a>数据库 Hasura</h3><p>restful api 与 Graphql</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>七层模型，最上面三层合并为一层，最终有五层</p>
<p>应用层</p>
<p>传输层：端到端，处理丢包 使用TCP（可靠 但是慢） UDP（快 不可靠） 用来处理多发漏发串码的问题</p>
<p>网络层：IP协议层 网络分布</p>
<p>数据链路层：</p>
<p>物理层</p>
<p>Socket（套接字）：</p>
<p>第三方库：HP SOCKET 可以粘包 加快开发速率</p>
<p>Protobuf</p>
<h3 id="Web全栈开发"><a href="#Web全栈开发" class="headerlink" title="Web全栈开发"></a>Web全栈开发</h3><p>前端：</p>
<p>后端：</p>
<p>数据库：</p>
<p>应用部署：</p>
<p>SCSS Webpack 用户体验</p>
<p>Vue</p>
<p>express caddy</p>
<p>云服务入门：CDN(内容分发网络) OSS</p>
<p>微信公众号后台：express-wx</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h4><p>深度学习框架，前向传播，反向传播，计算梯度，需要再GPU上跑</p>
<h4 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h4><p>硬件开发平台</p>
<h4 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h4><p>硬件描述语言，将逻辑翻译为电路</p>
<h4 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h4><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>gitbash的使用：</p>
<pre><code>git add readme.txt  添加文件到暂存区
git commit -m &quot;message&quot; 将暂存区的修改添加到仓库内
git remote add &lt;name&gt; &lt;address&gt; 添加远程仓库
git remote -v 查看远程库信息
git remote rm &lt;name&gt; 解除绑定
</code></pre>
<h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>程序是软件，输入是键盘或鼠标，输出是显示器</p>
<p>GUI程序，有CUI的程序成为GUI应用‘</p>
<h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>OS下面是硬件、上面是各种应用程序。输入输出先到达OS，再转交给对应的应用程序；输出先交给OS再反馈给用户。能用鼠标点击，出现图像的是GUI系统。</p>
<h4 id="文件、路径"><a href="#文件、路径" class="headerlink" title="文件、路径"></a>文件、路径</h4><p>机械硬盘：磁介质的两种磁化方式对应0、1；SSD电容充放电对应0、1；</p>
<p>纯文本文件，内部是直接的内容编码；</p>
<p>大多数与文字相关的文件是纯文本文件；.c .h .cpp .py .html .xml 以及一些配置文件和不带后缀的文件都是纯文本文件。打开纯文本文件需要一个能读懂编码的程序，成为文本编辑器。</p>
<p>媒体文件：类似于图片、音乐、压缩包；需要约定如何打开这些文件，需要专门软件来解析。</p>
<p>后缀名决定打开方式，后缀名是文件名的一部分。</p>
<p>程序（机器指令）本身也是0、1文件</p>
<p>计算机内的文件只分为这三类。</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>资源管理器：看文件的软件</p>
<p>文件系统是树状的层级结构，每一个文件都有一个路径。</p>
<p>绝对路径：从硬盘开始</p>
<p>LINUX的绝对路径：/users/../../.. 第一个/是根目录，就是硬盘；linux的根目录是硬盘</p>
<p>家目录：家目录是每个用户各自的文件夹，用<del>代替家目录；</del>/wxy/桌面</p>
<p>相对路径：已经有一个目录，再去描述目标文件的路径；.指当前文件夹，..指上级文件夹，../..指上上级文件夹</p>
<p>隐藏文件：一般是以.开头的文件和文件夹，还有一些其他文件也被隐藏。隐藏文件一般比较核心。</p>
<p>bin文件夹一般指 binary二进制，其中是一些可执行程序（？）</p>
<h3 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h3><h4 id="终端和SHELL"><a href="#终端和SHELL" class="headerlink" title="终端和SHELL"></a>终端和SHELL</h4><p>终端是黑窗口，是一个应用程序；可以开启多个SHELL(一个标签页)</p>
<p>Shell的功能是解析输入的命令：（通过空格来分割程序和参数）</p>
<ol>
<li><p>通过绝对路径来打开应用程序（以date文件为例，参数-r 可以接数字和文件名）</p>
</li>
<li><p>通过命令让shell来解析要调用的程序，例如输入date可以直接调用程序；shell的作用是解析字符串，它会在环境变量中寻找字符串对应的程序。环境变量是一系列存放命令行程序的文件夹</p>
<p>bin就是一个环境变量；这些单个的单词称作命令；又是也将整个一行称为命令，本质上是调用程序并且提供输入/参数；能用命令直接调用的程序称之为命令行程序</p>
</li>
<li><p>自己书写命令行程序</p>
<p>常用的shell命令</p>
<pre><code class="shell">与工作路径有关
pwd 显示当前路径
cd 更换路径至后面的参数
ls 列出当前目录所有文件和文件夹
ll 或 ls -l

与文件操作有关
mkdir 创建新文件夹
rm 删除文件
rm -d 删除空文件夹
rm -rf 删除文件夹
mv 移动文件
cp 复制文件
find 查找文件

与纯文本相关
vim 
touch 新建文本文件
cat &lt;file&gt; 查看文件内容
head &lt;file&gt; 查看文件的前十行

与命令相关
clear 清空终端
history 查看历史命令
man 查看某个命令的手册
xx --help (-h) 查看摸一个命令行程序的帮助

与进程相关
ps 查看当前进程
kill 向进程发生一些信号
</code></pre>
</li>
<li><p>命令行的文本编辑器vim</p>
<p>按i进入编辑模式，按esc退出编辑模式，按:输入编辑器的选项，用wp保存退出，cat可以查看；<a href="%5Bvim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_yxj%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_45379253/article/details/115872968)">更多指令</a></p>
</li>
<li><p>用g++编译链接文件，生成可执行文件</p>
</li>
<li><p>其他shell操作</p>
<pre><code class="shell">which shell如何解析输入
where 可能如何解析命令

grep 字符串搜索，可以用正则表达式

输入输出流重定向
例：
touch my.txt
echo &quot;hello world&quot; &gt; my.txt # 将输出覆盖到文件
echo &quot;hhhh&quot; &gt; my.txt # 将输出覆盖到文件
echo &quot;hahahaha&quot; &gt;&gt; my.txt # 将输出追加到文件

mkdir ha/haha 2&gt; /dev/null # 忽略错误
mkdir ha/haha 2&gt;&gt; error.log # 追加错误到日志文件中

&gt;：输出重定向到一个文件或设备 覆盖原来的文件
&gt;!：输出重定向到一个文件或设备 强制覆盖原来的文件
&gt;&gt;：输出重定向到一个文件或设备 追加原来的文件
&lt;：输入重定向到一个程序（如果你要做数算题，输入数据的时候可能会用到）
注：这里文件指的是纯文本文件；设备中有一个比较特殊的是/dev/null，如果你不需要输出的信息，你可以将信息重定向到这里

输入和输出表示：主要有三种输出入的状况，分别是：

标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;
标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;
错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;

管道：上一个命令的输出作为下一个命令的输入 |
左边是上一个命令，右边是下一个命令
</code></pre>
<pre><code class="shell">^c #即ctrl+c 结束当前的程序，或者重新输入命令
^d #退出一个shell
#部分符号需要反转译
#通配符 
* #匹配多个字符
? #匹配单个字符
tab 和右键补全（需要个性化配置）

#文件夹和文件权限
ll #查看文件类型 十位数字
chmod #更改权限
</code></pre>
</li>
</ol>
<h3 id="shell脚本（以sh作为后缀名）"><a href="#shell脚本（以sh作为后缀名）" class="headerlink" title="shell脚本（以sh作为后缀名）"></a>shell脚本（以sh作为后缀名）</h3><p>脚本：一种描述性语言，是一种可执行文件。本质上是一种纯文本文件，需要解释器（例如shell 或者python）来执行。</p>
<p>比较难写</p>
<h3 id="shell配置文件"><a href="#shell配置文件" class="headerlink" title="shell配置文件"></a>shell配置文件</h3><p>zsh配置文件 ~/.zshrc</p>
<p>bash配置文件 .bash_profile</p>
<p>推荐 missing semester</p>
<h3 id="命令行与GUI"><a href="#命令行与GUI" class="headerlink" title="命令行与GUI"></a>命令行与GUI</h3><p>GUI操作方便，但是占用资源非常多；最常见的只有命令行的操作系统是LINUX</p>
<h3 id="linux历史"><a href="#linux历史" class="headerlink" title="linux历史"></a>linux历史</h3><p>LINUX初衷是替代UNIX，现在的许多OS都是类unix系统</p>
<p>LINUX内核是开源的</p>
<p>LINUX发行版本：一些组织或厂商将LINUX内核与各种软件、文档包装起来，提供一些安装界面和系统配置等等；常见的有：ubuntu、CentOS</p>
<p>平时使用的说的都是LINUX的发行版</p>
<h3 id="LINUX文件系统"><a href="#LINUX文件系统" class="headerlink" title="LINUX文件系统"></a>LINUX文件系统</h3><p> Linux中，一切皆文件，文件、目录、管道、通配符都是文件</p>
<h3 id="上手linux"><a href="#上手linux" class="headerlink" title="上手linux"></a>上手linux</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>SSH远程链接</p>
<h4 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h4><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>虚拟机可以模拟出硬件，在硬件上跑其他的操作系统</p>
<h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>和虚拟机差不多，占用的资源更少，效率更高</p>
<h4 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h4><h4 id="云端服务器的功能"><a href="#云端服务器的功能" class="headerlink" title="云端服务器的功能"></a>云端服务器的功能</h4><p>处理请求 == 提供服务，处理多人发的请求的机器就是服务器；一般来说，一个端口对应一个服务</p>
<h4 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h4><p>LINUX上的包管理器是APT</p>
<h4 id="部署可以交互的小游戏"><a href="#部署可以交互的小游戏" class="headerlink" title="部署可以交互的小游戏"></a>部署可以交互的小游戏</h4><h4 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h4><p>当终止远程链接时，希望服务器上的程序能够继续运行，需要使用tmux</p>
<h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><p>GIT与GITHUB不同，GIT本身的源代码是开放的</p>
<p>安装后设置git config的–global参数，只用设置一次</p>
<pre><code class="shell">git init #初始化一个仓库
git add &lt;file&gt; # 添加文件到仓库
git status #提交状态
git commit -m &quot;message&quot; #提交当前的暂存区，标注为message
#若没有输入-m，会进入指定的编辑器（命令行EDITOR环境变量指定）
#-m 提交信息有着一定的规则
</code></pre>
<p>.gitignore文件中声明的文件和文件夹，文件类型</p>
<pre><code class="shell">/node_/ #忽略整个文件夹
*.cpp #忽略某种类型的文件、采用通配符
/node2/a.h #忽略某个具体文件，写相对路径
#可以增加!反向限制，即不忽略某个文件
</code></pre>
<p>版本回退</p>
<pre><code class="shell">git log #显示日志
git reset #回退版本
git checkout -- &lt;file&gt; #撤销暂存区的修改
git rm &lt;file&gt; #删除仓库里的某个文件
</code></pre>
<p>远程仓库</p>
<pre><code class="shell">git remote add origin &lt;name&gt; #关联远程仓库
git remote rm &lt;name&gt; #解除关联
git remote -v #查看远程库信息
git push &lt;remote name&gt; &lt;branch&gt; #推送修改
git fetch &lt;remote name&gt; &lt;branch&gt; #拉取代码到本地仓库
git merge &lt;branch&gt; #合并目标分支到当前分支
git clone #克隆远程分支到本地
</code></pre>
<p>分支管理</p>
<pre><code class="shell">git branch #显示所有分支
git branch &lt;name&gt; #以当前分支创建新分支
git checkout &lt;name&gt; #切换分支至
git branch -d &lt;name&gt; #删除分支
git merge &lt;name&gt; #合并分支
</code></pre>
<p>合并冲突</p>
<pre><code class="shell">#需要手动修复冲突
</code></pre>
<h2 id="GITHUB-ACTION"><a href="#GITHUB-ACTION" class="headerlink" title="GITHUB ACTION"></a>GITHUB ACTION</h2><p>CI/CD</p>
<h3 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h3><p>使用pep8(for python), eslint(for ECMAScript)进行代码格式化</p>
<h4 id="Linter"><a href="#Linter" class="headerlink" title="Linter"></a>Linter</h4><p>代码高亮</p>
<h4 id="单元测试以及集成测试"><a href="#单元测试以及集成测试" class="headerlink" title="单元测试以及集成测试"></a>单元测试以及集成测试</h4><p>每个函数的测试（类似OJ）、函数组合功能的测试以及代码覆盖率（测试用到的代码占比）</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>​        CI机器自动构建</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h2><pre><code class="shell">dotnet new console --output hello #创建一个程序
dotnet new --list #查看可以创建的项目类型
dotnet run --project &lt;name&gt; #运行
</code></pre>
<p>类型：</p>
<ol>
<li>值类型<ol>
<li>结构类型</li>
<li>枚举类型</li>
</ol>
</li>
<li>引用类型</li>
</ol>
<p>object是所有类型的基类，是引用类型，其句柄可以指向所有类型</p>
<p>对值类型的指向需要装箱、拆箱操作</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是一个类类型，为引用类型，支持UTF-8</p>
<p>字符串文本，用双引号括起来</p>
<p>逐字字符@开头，双引号引起，不需要转移，但是不能含双引号</p>
<p>可以插入变量，需要$开头，变量用花括号包含</p>
<p>自动推导类型 ver 关键字</p>
<p>值类型赋值，引用类型是更改句柄指向</p>
<p>可以在关键字前添加 @ 来使用关键字作为变量名，会自动忽略@</p>
<p>C#会自动垃圾回收，不需要手动delete堆内存</p>
<h3 id="C-入门"><a href="#C-入门" class="headerlink" title="C#入门"></a>C#入门</h3><p>输入输出</p>
<p>输出：</p>
<pre><code class="c#">System.Console.Write(&quot;&quot;);
System.Console.Writeline(&quot;&quot;); //附带一个换行
//可以格式化输出
</code></pre>
<p>输入</p>
<pre><code class="c#">system.console.read(); //读入一个字符并返回int
system.console.readline(); //读入一行字符串
//类型转换
system.convert.to...、、、//利用好自动补全进行转换
</code></pre>
<p>运算符：算数运算符、逻辑运算符、位运算符、三目运算符与C++一致</p>
<ul>
<li>？运算符 检查一个句柄是否为NULL</li>
<li>?? </li>
<li>??= </li>
</ul>
<p>控制结构，与C相同</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>引用类型，需要new出来</p>
<p>角标访问，length获取长度</p>
<p>foreach 关键字遍历元素</p>
<p>二维数组 arr[,] length是总长，getlength(i) 是i+1维的长度</p>
<p>交错数组 int [] [] arr</p>
<h3 id="C-面向对象初步"><a href="#C-面向对象初步" class="headerlink" title="C#面向对象初步"></a>C#面向对象初步</h3><pre><code class="c#">class ClassName&#123;
    public int x;
    public int y;//每一行（每一个字段）都需要权限限制，字段习惯小驼峰命名法
    public static int mn;//静态字段，需要用类名.字段名访问
&#125;//习惯用大驼峰命名法，每一个单词的首字母大写；附：小驼峰命名法，首字母不大写，其他一致
</code></pre>
<p>方法（即函数）</p>
<p>返回值、方法名、参数列表合成为方法的签名，方法习惯大驼峰，静态方法</p>
<p>方法的参数传递：值类型赋值（若想传入引用，需要在参数列表以及调用处加上关键字 ref），引用类型传入句柄</p>
<p>函数缺省值</p>
<p>构造方法无返回值类型，与C++相同，只是不能有初始化列表</p>
<p>简短函数可以用 =&gt;来直接返回</p>
<p>方法重载，参数列表不同即可</p>
<p>运算符重载必须是静态方法，可重载的运算符较少</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>一个属性包含两个部分：</p>
<ol>
<li>get 访问器 外部读取字段值</li>
<li>set访问器 外部设置字段值</li>
</ol>
<p>一般字段私有，绑定到公有的属性</p>
<p>一般使用时，只定义属性，让编辑器自动生成对应的私有字段，可以有默认值</p>
<h3 id="只读字段"><a href="#只读字段" class="headerlink" title="只读字段"></a>只读字段</h3><p>只能在构造方法里被赋值 readonly 关键字</p>
<p>将set 改为init 可以将属性只读化</p>
<p>类和嵌套类 protected 权限 只有外部类的派生类能看到</p>
<p>partial 类 可以分成几部分定义</p>
<p>继承没有权限的问题，不需要限制public继承，一个类有且只能有一个基类</p>
<p>为基类提供构造参数通过初始化列表</p>
<p>密封类sealed 关键字，密封类不能再被继承</p>
<h4 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h4><p>变量 is 类型  返回布尔值</p>
<p>is not 相反</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>抽象类 abstract 关键字，可以定义抽象类、抽象方法</p>
<p>虚方法需要加上 virtual关键字</p>
<p>虚方法必须定义函数体，抽象方法不能定义函数体，抽象方法必须写在抽象类当中</p>
<p>重写覆盖需要 override关键字</p>
<p>属性也可以定义为虚的和抽象的</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口属于引用类型，是没有字段只有方法的类，需要用interface而不是class定义</p>
<p>命名一般采用大驼峰，且以大写字母I开头</p>
<p>一个类可以继承多个接口，接口内方法的权限默认是public</p>
<p>接口可以定义属性</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>只需要在类或者方法后加上&lt;T&gt;即可</p>
<p>可以对泛型进行约束 where关键字</p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托是一种引用类型，与函数指针类似，需要delegate关键字</p>
<pre><code class="c#">delegate int BinaryFuntor(int x,int y); //定义委托类
int Add(int a.int b) =&gt; a+b;
BinaryFuntor add = new BinaryFuntor(Add);//构建句柄
</code></pre>
<p>内置委托 action func</p>
<p>委托函数 多播委托 可以用+来增加多个方法</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>（参数列表）=&gt; 返回值</p>
<p>（参数列表）=&gt; {返回语句}</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是一种委托</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="可为空的类型"><a href="#可为空的类型" class="headerlink" title="可为空的类型"></a>可为空的类型</h4><p>int?  即正常的int类型，同时支持赋值为null</p>
<p>可为空的值类型与不可为空的值类型不是同一个类型 int? int 不同</p>
<p>而可为空与不可为空的引用类型是同一个类型</p>
<h3 id="托管与垃圾回收"><a href="#托管与垃圾回收" class="headerlink" title="托管与垃圾回收"></a>托管与垃圾回收</h3><p>GC 垃圾回收机制</p>
<p>终结器  （析构函数）</p>
<p>非托管资源</p>
<p>语言继承查询</p>
<h2 id="多线程与异步"><a href="#多线程与异步" class="headerlink" title="多线程与异步"></a>多线程与异步</h2><p>计算机架构：冯诺依曼架构、哈佛结构</p>
<p>CPU架构： PC x86; pe arm; mips ;risc-v</p>
<p>操作系统：内核、shell、GUI</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的一个被隔离的单独的程序就是一个“进程”。</p>
<p>虚拟内存：每个进程在运行时都被分配了一块虚拟的内存</p>
<p>进程的三个状态：</p>
<ol>
<li>运行态 正在吃</li>
<li>就绪态 饿了等着拿到筷子</li>
<li>阻塞态 等着上桌</li>
</ol>
<p>进程的调度：轮流安排多个进程并行地执行</p>
<p>上下文切换：记录进程停止时的状态，切换为另一个进程的状态</p>
<p>linux进程： ps 命令；kill 可以杀死进程</p>
<p>前台进程占据当前SHELL,后台进程不占用，创建后台进程需要在后面加上&amp;,使用jobs可以查看当前的所有后台进程，使用fg可以将后台进程转换至前台</p>
<p>对LINUX C++进程的函数为</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在一个进程内同时运行多个线程，不同线程之前可以共享资源</p>
<h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><p>pthread.h头文件C++</p>
<p>C#中的线程库 Thread类</p>
<p>C#线程分为前台线程、后台线程</p>
<p>前台线程会阻塞整个程序的退出，后台线程则会在整个程序退出时自动结束</p>
<p>默认情况下是前台线程，可以改为后台线程</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>预先开辟多个线程、然后等需要的时候，直接使用已经创建好的线程以减少开销</p>
<p>一般情况下使用封装好的task timer等间接使用线程池</p>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><ul>
<li>传递信息：<ul>
<li>套接字</li>
<li>管道</li>
</ul>
</li>
<li>资源竞争</li>
<li>顺序的正确性</li>
</ul>
<h4 id="原子操作（原语）"><a href="#原子操作（原语）" class="headerlink" title="原子操作（原语）"></a>原子操作（原语）</h4><p>原子操作：不可再分的操作</p>
<p>为了防止线程切换时打断某些复杂操作，使得部分简单步骤丢失，引入原子操作；即每一次对线程的打断保证刚刚执行的操作被完全进行完毕。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>资源竞争问题，将共享的资源、数据片段称为临界区，要求两个线程不能同时进入临界区，要求：</p>
<ol>
<li>任何两个进程不能同时进入临界区</li>
<li>对CPU的速度、数量没有要求</li>
<li>临界区外运行的进程不能阻塞到其他进程</li>
<li>不能让一个进程无限期等待进入临界区</li>
</ol>
<p>忙等待：一直进行判断，尽量避免忙等待</p>
<p>忙等待的方法，不好！</p>
<p>休眠与唤醒方法：</p>
<p>当进程无法进入临界区时，让进程睡眠，进程退出临界区时，唤醒另一个进程</p>
<p>也不太好</p>
<p>信号量的方法：（正确解法）</p>
<p>一个信号量含一个整数来计数（资源总量），以及两个原子操作，即把睡眠唤醒方法的判断和睡眠两个操作合为一个，把判断和唤醒合为一个</p>
<p>分为P操作、V操作</p>
<p>信号量可以解决生产者——消费者问题</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>信号量的初始值为1，称为互斥量，P称为加锁，V称为解锁</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>与互斥量配合使用，在互斥量已经加锁的条件下，条件变量的基本操作有三个：</p>
<ol>
<li>解锁并开始休眠</li>
<li>唤醒一个进程</li>
<li>唤醒所有进程</li>
</ol>
<p>存在的问题：信号丢失、虚唤醒</p>
<h3 id="c-的支持"><a href="#c-的支持" class="headerlink" title="c#的支持"></a>c#的支持</h3><p>system.threading.semaphore</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁一般与资源的获取有关</p>
<p>死锁：两个进程想要对方的资源，又都不愿意释放</p>
<p>处理方法：破坏死锁的形成条件四者之一</p>
<h3 id="其他经典IPC问题"><a href="#其他经典IPC问题" class="headerlink" title="其他经典IPC问题"></a>其他经典IPC问题</h3><ul>
<li>哲学家就餐<ul>
<li>编号，一个人先拿左边再拿右边，其他人先拿右边，再拿左边</li>
</ul>
</li>
<li>读者-写者问题（多个进程读，只能一个进程写且不能同时读）<ul>
<li>读者优先</li>
<li>由于过于复杂，大多数语言提供了读写锁</li>
</ul>
</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="TASK"><a href="#TASK" class="headerlink" title="TASK"></a>TASK</h4><p>创建task System.Treading.Tasks内的task类</p>
<h2 id="Winform"><a href="#Winform" class="headerlink" title="Winform"></a>Winform</h2><p>常用控件</p>
<ul>
<li>labal 显示静态文本</li>
<li>Textbox 支持输入文本</li>
<li>Button 触发事件 IDE内双击生成事件函数</li>
</ul>
<p>可以手工添加控件</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Anchor: 锚定到边远</p>
<p>dock: 停靠到边远</p>
<p>用panel进行布局</p>
<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p>为事件指定回调函数</p>
<p>对按钮来说，可以在设计器里双击</p>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>去窗口上手动绘制交互界面</p>
<p>使用窗口的paint事件</p>
<p>绘图在最底层显示</p>
<h3 id="玩玩就好，不太好用"><a href="#玩玩就好，不太好用" class="headerlink" title="玩玩就好，不太好用"></a>玩玩就好，不太好用</h3><h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><p>XMAL：描述性语言</p>
<p>APP是逻辑，入口</p>
<p>MainWindow是窗口</p>
<h3 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h3><p>使用Stackpanel容器来布局，单向排列，超出不会显示</p>
<p>WrapPanel:支持换行换列</p>
<p>DockPanel：最常使用，</p>
<h3 id="控件（control）"><a href="#控件（control）" class="headerlink" title="控件（control）"></a>控件（control）</h3><p>三种：</p>
<ul>
<li>ContentControl</li>
<li>ItemControl</li>
<li>TextBoxBAse</li>
</ul>
<p>控件之间可以相互嵌套</p>
<p>提倡数据系统</p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>字体的颜色、大小、边距、位置，作为预先设计好的外观</p>
<p>推荐写入application resources</p>
<p>触发器：类似于事件</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul>
<li>控件模板</li>
<li>数据模板</li>
</ul>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>Binding 元素绑定到控件的元素</p>
<p>绑定至context</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>分离界面与后台逻辑代码，利用数据绑定函数</p>
<h4 id="prism"><a href="#prism" class="headerlink" title="prism"></a>prism</h4><p>案例分析：下载器</p>
<h2 id="JS-TS-yarn-NodeJS"><a href="#JS-TS-yarn-NodeJS" class="headerlink" title="JS TS yarn NodeJS"></a>JS TS yarn NodeJS</h2><p>Js解释型的脚本语言，在cmd中node启动node.js</p>
<h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>可以用中文作为变量名，动态类型，可以保存不同类型的数据</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>**求幂 === 数值、类型均相同、一元的+运算符、字符串＋直接链接字符串</p>
<p>解构操作：</p>
<pre><code class="js">[a,b,...rest]=[1,2,3,4,5]
rest=[3,4,5]
...rest=3,4,5
</code></pre>
<p>控制结构</p>
<p>for的三种用法</p>
<p>函数</p>
<p>使用function关键字，也可以lambda表达式</p>
<p>arguments对象：函数参数的储存数组</p>
<p>剩余参数：允许将不确定数量的参数表示为数组</p>
<pre><code class="javascript">function multiply(factor,...theArgs)&#123;
    return theArgs.map((x)=&gt;factor*x);
&#125;
console.log(multiply(3,4,5,1,2,3));//从第二个参数开始作为一个数组
</code></pre>
<p>对象：名称-值对</p>
<pre><code class="js">var obj=&#123;&#125;;
var obj2=&#123;
    age:15,
    name:&quot;adawd&quot;,//注意逗号
&#125;
obj2.name;
Object.keys(obj2);
//Array对象
forEach();
//map

//reduce()

//Proxy
const p = new Proxy(target,handler);
//target是被隐藏权限的对象
var handler=&#123;
    get:function(obj,prop)&#123;
        return prop in obj? obj[prop]:&quot;NULL!&quot;;
    &#125;,
    set:function(obj,prop,value)&#123;
        obj[prop]=value;
    &#125;,
&#125;;
var person=&#123;
    name:&quot;2333&quot;,
    age:25,
&#125;
var p =new Proxy(person,handler);//固定是handler,需要重载它的内置方法，还有get,set之外的属性
console.log(p);
p.name=&quot;awdawfa&quot;;
</code></pre>
<p>异常处理</p>
<pre><code class="js">//throw语句扔出异常
//try...catch语句捕获
//有异常会执行catch的语句，否则不执行
//最后可以跟上finally语句，总会执行
function getm(mo)&#123;
    mo=mo-1;
    var months=[
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
    ];
    if(months[mo])&#123;
        return months[mo];
    &#125;else&#123;
        throw &quot;223&quot;;
    &#125;
&#125;
try&#123;
    m=getm(15);
&#125;catch(e)&#123;
    m=&quot;unknown&quot;;
    console.error(e);
&#125;finally&#123;
    console.log(m);
    console.log(&quot;done!&quot;);
&#125;
</code></pre>
<p>模块（类似于python）import导入</p>
<p>异步和阻塞</p>
<pre><code class="js">//异步回调
setTimeout(()=&gt;&#123;
    console.log(&quot;hi&quot;);
&#125;,20000);
console.log(&quot;bye&quot;);//使用回调函数实现异步
//Promise
fetch(url)
    .then(console.log(&quot;a&quot;))
    .then(console.log(&quot;b&quot;))
    .catch(console.log(err))
    .finally&#123;
        console.log(&quot;ok&quot;)
    &#125;;
//fetch返回一个promise，promise.then()会返回一个promise，then()包含一个回调函数，接收前一步的结果作为输入
//async/await语法糖
let hello = async()=&gt;&#123;//async关键字将函数变为异步函数，添加promise对象
    return &quot;2333&quot;;
&#125;
hello().then((a)=&gt;&#123;
    console.log(a+a);
&#125;);
console.log(hello());

//使用await版本
let hello = async()=&gt;&#123;//async关键字将函数变为异步函数，添加promise对象
    return &quot;2333&quot;;
&#125;
async function deal()&#123;
    var a=await hello();//即先阻塞这个函数，等await后部分执行完毕后再继续执行
    console.log(a);
&#125;
deal();
</code></pre>
<h4 id="文档MDN"><a href="#文档MDN" class="headerlink" title="文档MDN"></a>文档MDN</h4><h3 id="npm-yarn"><a href="#npm-yarn" class="headerlink" title="npm yarn"></a>npm yarn</h3><p>包管理工具</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>强类型的js改版，需要安装typescript包</p>
<p>tsc –init 来初始化生成json文件</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>一种罗列元素的语言</p>
<p>元素</p>
<pre><code class="html">&lt;h1&gt;233&lt;/h1&gt;
&lt;p&gt;adaw&lt;/p&gt;
&lt;em&gt;aaa&lt;/em&gt;&lt;strong&gt;标签可以嵌套&lt;/strong&gt;
</code></pre>
<p>块级元素：相对于前面元素会出现在新的一行</p>
<p>内联元素：出现在一堆块级元素之间</p>
<p>空元素：一些元素只有一个标签，没有结束标签</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>基本写法</p>
<pre><code class="html">&lt;p class=&quot;foobar&quot;&gt;
    2333
&lt;/p&gt;
</code></pre>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul>
<li>声明类型</li>
<li>html元素</li>
<li>head元素</li>
<li>&lt;meta charset=”utf-8”&gt;：元数据</li>
<li>title元素</li>
<li>body元素</li>
</ul>
<h3 id="在html中应用css和js"><a href="#在html中应用css和js" class="headerlink" title="在html中应用css和js"></a>在html中应用css和js</h3><p>CSS：样式语言</p>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;./main/my.css&quot;/&gt; 引入样式，一般放在head里
或者写在元素里
&lt;script src=&quot;./main/my.js&quot;&gt;&lt;/script&gt; 一般放在结尾的&lt;/head&gt;前
</code></pre>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>一门给予规则的语言：由一个选择器开头，后接一对大括号，在大括号里定义一个或多个属性，定义样式</p>
<p>元素选择器，匹配对应的元素，不同的选择器可以放在一起；元素选择器比较笼统</p>
<p>单独选择一个元素可以定义类</p>
<h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><h2 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h2><p>正则表达式爬取</p>
<h2 id="JS-TS实现交互"><a href="#JS-TS实现交互" class="headerlink" title="JS TS实现交互"></a>JS TS实现交互</h2><p>DOM</p>
<h2 id="SCSS-Sass"><a href="#SCSS-Sass" class="headerlink" title="SCSS/Sass"></a>SCSS/Sass</h2><p>CSS的预处理器，独特的语法来生成CSS的程序</p>
<p>node 或者 yarn 安装 sass安装包</p>
<pre><code class="bash">sass input.scss output.css #单文件转换命令
sass --watch input.scss:output.css #单文件监听命令，监听：源文件更改后自动编译
sass --watch app/sass:public/stylesheets #监听整个目录
</code></pre>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><pre><code class="scss">//变量
$age: 4;
$color: #333;
//一个变量可以引用另一个变量
//作用域为大括号
//选择器可以嵌套，父选择器&amp;，属性名可以嵌套
//交互式命令行
sass -i;
@debug a;//输出a
@use &#39;base&#39;; //引入模块base.css
//混入器，类似于宏
@mixin;
//占位符类
//支持运算符
//插值，可以在选择器或者实行名中使用变量、
//条件控制，循环，下标从1开始，函数
//内置模块
</code></pre>
<h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><p>不涉及代码</p>
<h3 id="平面设计基础"><a href="#平面设计基础" class="headerlink" title="平面设计基础"></a>平面设计基础</h3><p>排布页面：</p>
<ul>
<li>少即是多 有序整齐<ul>
<li>字体种类要少一点，色彩要少，减少艺术字效果，字号少，对齐线，学会留白</li>
</ul>
</li>
<li>对齐和网格，格栅</li>
<li>信息组织<ul>
<li>相关分类</li>
<li>相同——对比</li>
<li>层级信息</li>
<li>主次关系</li>
</ul>
</li>
<li>用图说话  <a href="Thenounproject.com">图标网站</a></li>
</ul>
<h3 id="界面交互"><a href="#界面交互" class="headerlink" title="界面交互"></a>界面交互</h3><p>Adobe XD 交互界面设计软件</p>
<ul>
<li>设计统一，设计标准</li>
</ul>
<p>ant design组件库 中文文档</p>
<p>组件色彩</p>
<p>网格布局、格栅：列和沟 列起列收</p>
<p>一般宽长比为8:4的倍数</p>
<h3 id="交互认知"><a href="#交互认知" class="headerlink" title="交互认知"></a>交互认知</h3><p>位置定位 按钮反馈</p>
<p>动态效果</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>前端：PHP Js jQuery库 </p>
<p>jQurey库 插件一般放在结尾之前 很过时</p>
<p>构建工具：Bundler  简化代码，同时易于开发，输入js项目，输出可以在浏览器上运行的代码</p>
<p>工业标准：commomjs</p>
<h2 id="express-后端"><a href="#express-后端" class="headerlink" title="express 后端"></a>express 后端</h2><p>原始：基于表单、模板渲染驱动</p>
<p>现在：基于AJAX驱动</p>
<h3 id="API-HTTP请求"><a href="#API-HTTP请求" class="headerlink" title="API HTTP请求"></a>API HTTP请求</h3><p>请求、响应  状态</p>
<p>Postman发送网络请求的工具</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求处理函数</p>
<p>ruquest对象 response请求</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>前端开发框架</p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>What is Vue.js?</p>
<p>渐进式的前端开发框架 MVVM</p>
<p>两个大括号包起来的是插值 只在data以及另外一个 属性中成立</p>
<script src="https://unpkg.com/vue/dist/vue.js"></script>

<p>谓词 v-if（条件） v-on （监听点击） v-for (循环) v-bind（双向绑定）</p>
<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p>context 对象</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>关系型数据库 MySQL 数据需要有一定的规范</p>
<p>MongoDB</p>
<h2 id="Hasura"><a href="#Hasura" class="headerlink" title="Hasura"></a>Hasura</h2></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/08/22/SQL/" title="SQL初探"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: SQL初探</span></a><a class="button is-default" href="/2021/06/11/OOP%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="OOP期末复习"><span class="has-text-weight-semibold">下一页: OOP期末复习</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Teburile/blog-comments" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Teburile"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright © </span><span> Teburile 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>