<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MarkDown博客的视频外链测试</title>
      <link href="2022/04/21/%E8%A7%86%E9%A2%91%E5%A4%96%E8%81%94%E6%B5%8B%E8%AF%95/"/>
      <url>2022/04/21/%E8%A7%86%E9%A2%91%E5%A4%96%E8%81%94%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试</p><span id="more"></span><center>测试视频</center><video src='https://cloud.tsinghua.edu.cn/f/7b89b52a26fb43b9b14b/?dl=1 ' type='video/mp4' controls='controls'  width='100%' height='100%'></video>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 年度总结</title>
      <link href="2022/01/17/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>2022/01/17/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="春花秋月何时了，往事知多少"><a href="#春花秋月何时了，往事知多少" class="headerlink" title="春花秋月何时了，往事知多少"></a>春花秋月何时了，往事知多少</h3><p>又是一年白驹过隙，大学的光阴总是飞箭般穿梭，只留下自己一人黯然神伤与感慨万千。</p><p>不得不说，刚过去的一年是繁忙的一年，有太多的记忆和念想。挫折很多，成长很多，追忆亦很多。从战战兢兢如履薄冰的小伙子成长为了一个拒绝社恐、敢于辩论的新人类。</p><p>回首这一年的成长，确实自己对文史哲、对形而上、对这些虚无缥缈而有高远的东西有了更多的热爱。虽然说这些爱好并不能帮自己解决一些肩膀上的负担或是他人的希冀，但它们助我成为纯粹的人、成为爱思考非机械的人。我看了很多书，从《人类简史》到《枪炮病菌与钢铁》，从《全球通史》到《信息简史》，当然，书不能仅仅局限在这种可以翻来翻去以文字为主的存在形式上，像马原老师的PPT，像杜导的党史讲座，像读而未尽的《共产党宣言》，都是一种阅读，都是一种和伟大灵魂、伟大精神的深入交流。还有自己操办的主题团日，虽然主题只是一时兴起蹭热度，相关工作也分锅给了各位班委，但整体效果来看，团日效果相当不错，也算是在完成政治任务同时学到了一些东西。以史为鉴，可以知兴替；不知怎的，最近尤其喜欢读史书，尤其是世界通史以及人类史（这里是我自己定义的人类史，可能与专业定义不同）、史前史。但期中考试以来，DSA 的 PA，社工、主题团日的大锅以及 13 周便开始的复习步伐，让人夙兴夜寐，靡有朝矣！这些压力，中断了阅读，也中断了一种追求，甚至开始减少这种习惯的坚定和力量，甚至成为一种辛苦之后长久放纵的万恶之源！但我不能放纵，亦不能颓废，一周多的休养、颓唐之后，应当开始全神贯注，用心做大事了。无论是一开始设想的自定义的时间轴，还是现在压在心头的学术新星论文阅读，总要开始做的，不能再拖沓了。</p><p>一年以来，家乡也是多灾多难，疫情、洪水再到疫情，很多假期编排的诸如学车之类的活动也只能一拖再拖，天灾面前只能尽人事、听天命。而在这即将到来的寒假当中，我又是冬奥志愿者，自然难以返回疫情肆虐的故乡，值此危难之际，怎能不让人无限思念与伤感。君不见，桑梓愁，万里悲怆如毒钩！</p><p>曾经满腔热血，一心奉献；怀着昂扬的斗志接下了三个社工，而今看来，有些岗位已不值得付出。学生工作责任之重大，存在之必要，自可知也；然工作分配之方式，工作完成之回馈，工作开展之辅助，有云泥之别也！非谓自身怠慢懈惰，是管理之腐朽，主义之形式，其常以冷雪浇人热火，常以冰霜冻人激情，常以不均抑人追求，常以傲慢恶人心脾。如此这般、如此那般，不得不使人心生厌恶。除此之外，亦有一二九、codeplay之类临时工作，虽有激励和总结，但终究非长久的社工，不再论说。</p><p>说到文艺和体育，这两个方面的教育也当然是十分重要的！柏拉图的教育观点就是：一个人要文体并重，体育教育和音乐教育可以塑造一个人的人格和灵魂，把人培养成完善的存在。虽然从自我、学校以至于先贤都盼望着我能够文体两开花，但不得不承认的一点是，在狭义的，或者说是更广为人所认可的文体的观念下，我自身并没有做到自我的文体教育及其提高；但在某种更加广义的角度上，我的文体发展是有所前进的。在下半年，我学会了游泳，又达成了一项从学校毕业的条件，暑期之前也经历了军训，也算是一种体育的进步吧；而文艺方面，我继续保持了自己读书的习惯，也第一次欣赏了音乐剧《歌剧魅影》，接触了一种新的文艺形式；这一年，我也看了许多部电影，补齐了《觉醒年代》和《亮剑》，畅玩了许多新的游戏，也在一定程度了娱乐了自我，也提高了自我。</p><p>对于实践，则不像文艺一样，需要把这个范畴进行外延才能找到相关的事迹，我在刚过去的一年确实有实实在在的实践经历。一方面，跟着班里的大部队在建党百年的光荣时刻去了上海，去参观了一大的会址，也去看望了《新青年》的编辑部旧址，在某种意义上，这些活动都为我目前所具有的一种对党的狂热，对共产主义理想的信仰，对一种绝对正义理念的理想主义有着催化促进作用。</p><p>其实回首这一年，有很多的场景会从眼前浮现，那些映入眼帘的人、事、物；那些光影下的蹁跹，那些岁月里的吟诵，何尝不是一种美好。事实上，过去的一年远不止上面所讲到的这些生活、这些文体、这些实践，但越是书写，就越发地感觉到，文字是苍白的，表达是孱弱的，那些掩藏在七彩生活中的无限细节与无限真实，很难在短短的一些总结当中表达出来。</p><p>这一年里，不知道为什么，或许是发端于《共产党宣言》和《觉醒年代》，催化于党史讲座，成长于上海一行，深化于马原课程，自己的理想主义情怀和一种马克思主义思想在肆意地生长蔓延，在用一种难以名说的方式影响自己，是好是坏，犹未可知。</p><p>当然，除了这些光伟正，除了这些极其积极的成分，生活中更多的还有欢乐和悲伤，更多的还有希冀和幻灭，还有追索与碰壁，愿他日回眸之时，能不忘青年之志，能守七义之心！</p><p>起首新庚，更甚盼之。其一，为茁壮成长身体健康；其二，为坚守我心不落沆瀣；其三，为寻得一方举案齐眉；其四，为着业有成告慰父老；其五，为推己及人造化近窗；其六，为瘟君既往天下无恙；其七，为河清海晏华夏永昌！</p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页开发纪实</title>
      <link href="2021/08/27/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E7%BA%AA%E5%AE%9E/"/>
      <url>2021/08/27/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E7%BA%AA%E5%AE%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="网页开发纪实"><a href="#网页开发纪实" class="headerlink" title="网页开发纪实"></a>网页开发纪实</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在刚刚学习过了HTML、CSS、JavaScript之后，Teburile感到有些手痒，心中有无限的创意想要施展出来。经过两天艰苦卓绝的斗争，大概获得的战果是这样的：</p><p><img src="https://gitee.com/teburile/picgo/raw/master/img/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%8E%B0%E7%8A%B6.jpg" alt="毕业论文现状"></p><p>虽然说，<a href="%22server.teburil.tk%22">结果</a>不是那么好看，但是，著名企业家罗老师说过，“又不是不能用！”。本着学习新知的心态，Teburile打算回忆一下这两天都<del>摸了什么鱼</del>做了些什么惊为天人的<del>垃圾代码</del>操作。</p><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>Teburile一开始只是想试试js，于是选择做一个登录的页面，于是从网上<del>嫖</del>借鉴来了一部分html和css代码，做了一个基本的、丑丑的样式，虽然难看，但最起码能用。后来，为了利用自己写后端的约等于没有的能力，Teburile用FastAPI开了一个简单的后端，用if-else操作！</p><p>试运行，在本地，简直完美！</p><p>为了让登录的效果看上去好一点，Teburile把前几天写的一个简单的网页做成了主页面，上面放着大大的<em><strong>广告位招商</strong></em>（因为有人和Teburile商量要买这个位置），还有从植吧爬来的《九章阵华录》，看上去还可以。</p><p>为了不浪费这个现成的前后端分离的网页，Teburile忽悠一位大腿，把项目放在了树莓派上，悄悄对外开放。看上去有那味了。</p><p>大腿嫌弃网页不太好看，建议Teburile放一张背景图片，于是Teburile想尽一切办法做到了，大概是使用CSS的伪类（具体他也不太懂）。当天一直到晚上，工作就是美化这两个丑丑的页面。</p><p>虽然有基本的登录验证，但是好像直接访问主页面的文件可以直接进去，这是一个大问题，得修！</p><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>为了解决昨天那个问题，大腿向Teburile建议看看cookie，于是Teburile通过这个东西，<del>摸了一上午的鱼</del>做出了限制跳转的解决方案。</p><p>具体是这样的：</p><ol><li>测试工程师A进入登录页面，输入账号密码，正确。js创建cookie，然后进入主页面，一切安好。</li><li>测试工程师A关闭主页面、登录页面标签，强行进入主页面，访问时，检测到有cookie，检测其中的账号密码，<del>天王盖地虎，宝塔镇河妖</del>暗号正确，于是A顺利进入了主页面。</li><li>测试工程师B强行进入主页面，没有检测到cookie，被js强行跳转到了登录页面，让他<del>乖乖站好</del>登录。</li><li>测试工程师A关闭浏览器，重新打开，强行进入主页面，这时，神奇的事情发生了，只有中午的时候，cookie被保存的下来，能够顺利进入，其他时候就不行。<del>懂了，这是“这破网页早晚得挂掉”意思吧。</del>这个问题到目前为止，Teburile都没有头绪，但最起码，“又不是不能用！”<del>圣经</del></li></ol><p>经过这一番cookie的折腾，这网页看着逐渐正规了起来。为了更加正规一点，Teburile想把废弃了的注册方案重新捡起来。</p><p>当天下午，Tebur重新打开了Python，想要用数据库管理。他想使用支持多并发的MySQL，但是又懒得安装数据库、懒得开端口，于是又双叒叕捡起了SQLite，仿照上次的代码，Teburile复刻了几乎一模一样的登录以及注册后端。这次不一样的是，Teburile对传输的密码进行了MD5加密，<del>天大的进步！</del></p><p>虽然比较简陋，但后端不还是开起来了吗？</p><p>于是他有着手书写前端，仿照登录页面，复刻了同样丑丑了注册界面，很顺利的，前后端能够正常使用，两天的努力也算是有个回报。</p><h3 id="中间碰到的奇奇怪怪的问题"><a href="#中间碰到的奇奇怪怪的问题" class="headerlink" title="中间碰到的奇奇怪怪的问题"></a>中间碰到的奇奇怪怪的问题</h3><p>除了上面说的那个cookie的问题，Teburile还发现了其他的问题。</p><p>比较头大的一个是跨域（CORS）的问题：</p><blockquote><p>什么是跨域呢？大概就是，网页在10001端口，而后端在10002端口，网页给后端发请求，但不是原本的端口。可以理解为，我上自习课要找同桌说话，这时老师就把我拦下来了。同样也是，浏览器会拦截跨域的请求。但是，我可以提前向老师打报告，说有重要的事要请教，也就可以说话（小声）了。只要在fatch请求当中把模式（mode）调整为跨域（cors），就可以顺利发出去请求了。</p><p>但是这样还不够，同桌自己在好好写作业，莫名其妙有人要请教，终归是不太好看。但是同桌（大腿）可以声明，自己这节课没事干，想来请教的尽管放马过来。只需要后端在监听时声明，哪些IP哪些请求可以跨域访问，就可以顺利的请求到想要的资源。</p><p>经过这一番折腾，我上自习课解决了问题，网页也成功从后端拿到了数据。大概就是这样</p></blockquote><p>另外一个就是网络传输协议的问题，带不带S的问题：</p><blockquote><p>Teburile发现，给http端口发送https请求会报错，反过来也是这样，看上去非常地合理。但问题在于，有些时候，并没有意识到自己是哪一个端口。</p><p>就像是大腿的树莓派，挂载的域名是https，但是Teburile经常就会发送http请求；本地的uvicorn开启热重载的端口是http请求，用chorme的API插件发送时，经常写错成https请求，也是非常不靠谱了。</p></blockquote><p>至于其他的问题，Teburile暂时也想不起来了。</p><h3 id="总结？"><a href="#总结？" class="headerlink" title="总结？"></a>总结？</h3><p>大概看看这个项目，都用了什么。</p><p>前端，也就是网页，用了HTML、CSS、JS，分别实习网页框架、网页美化和网页逻辑（包含给后端发送请求。）</p><p>后端，也就是处理的地方，只用了Python，但是用了FastAPI、SQLalchemy两个包，前者用了监听前端的请求，后者用来操纵数据库，中间的逻辑则由Python完成。</p><p>整个项目也算是大杂烩了吧。</p><p>Teburile有点<del>想摸鱼</del>困了，今天就写到这里吧。</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpage </tag>
            
            <tag> record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器开发者工具简介</title>
      <link href="2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
      <url>2021/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器开发者工具"><a href="#浏览器开发者工具" class="headerlink" title="浏览器开发者工具"></a>浏览器开发者工具</h2><p>[TOC]</p><p>使用f12或右键检查元素打开</p><h3 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h3><p>默认打开的是检查器，可以看到HTML\CSS，一般左侧为DOM检查器，看到HTML，右侧为CSS编辑器，看到当前选中元素应用的样式</p><p>DOM检查器：可以编辑元素、右键提供了一些功能</p><p>CSS编辑器：可以更改样式的值，每个规则右上有规则定义的文件名和行号；其他标签：计算：显示当前元素的计算样式；</p><h3 id="JS调试器"><a href="#JS调试器" class="headerlink" title="JS调试器"></a>JS调试器</h3><p>微软浏览器的调试位于 源 标签内，可以调试js ts，添加断电，监视变量</p><h3 id="JS控制台"><a href="#JS控制台" class="headerlink" title="JS控制台"></a>JS控制台</h3><p>可以用来实时执行一些Js代码，实现某些效果</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_are_browser_developer_tools">什么是浏览器开发者工具？ - 学习 Web 开发 | MDN (mozilla.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> introduction </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduce to JaveScript</title>
      <link href="2021/08/25/javaScriptNote/"/>
      <url>2021/08/25/javaScriptNote/</url>
      
        <content type="html"><![CDATA[<h2 id="JS初探"><a href="#JS初探" class="headerlink" title="JS初探"></a>JS初探</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>js的类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Symbol</li><li>object<ul><li>Function</li><li>Array</li><li>date</li><li>RegExp（正则表达式）</li></ul></li><li>null</li><li>undefined</li></ul><p>Js的数字都是浮点数，没有整型</p><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>注释、大部分运算符与C++相同</p><p>等于为 === (要求类型和值都相等)  不等于为 !==</p><p>等于 == 只要求值相等，判断时，类型不同会转化成同种类型然后判断</p><p>if-else 语句与C++相同 三目运算符与C++相同</p><p>定义函数在返回值的地方书写function即可</p><pre><code class="javascript">function add(num1,num2)&#123;    return num1+num2;&#125;</code></pre><p>while do-while for 循环语句与C++相同</p><p>对于迭代类型有 for of  for in 两种</p><pre><code class="js">for(let i in arr)&#123;    console.log(i);//输出的是角标 0 1 2 3 &#125;for(let i of arr)&#123;    console.log(i);//输出的是值 arr[0] arr[1] arr[2]&#125;</code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>js的对象都是名称-值对，类似于json，值可以是对象，也可以是函数</p><pre><code class="js">var obj=&#123;    name:&quot;233&quot;,    isFinished:true,    child:&#123;        color:blue,        size:12    &#125;,    getname: function()&#123;        return this.name;    &#125;&#125;obj.child.color;// blueobj[&quot;child&quot;][&quot;size&quot;];//12</code></pre><p>js的函数类似于C++的类</p><pre><code class="js">function Person(name,age)&#123;    this.name=name;    this.age=age;&#125;var you=new Person(&quot;you&quot;,20);//创建一个对象</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>角标从0开始，有长度函数，长度比最大索引大一，可能a[0] a[1] a[3] 赋值，但a[2]为undefined 则长度为4</p><p>遍历数组推荐使用 for..of</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>js的函数可以传入不确定个数的参数</p><pre><code class="js">function add(...args)&#123;    var sum=0;    for(var i of args)&#123;        sum+=i;    &#125;    return sum;&#125;</code></pre><h3 id="为类（对象）添加方法"><a href="#为类（对象）添加方法" class="headerlink" title="为类（对象）添加方法"></a>为类（对象）添加方法</h3><pre><code class="js">function personFullName()&#123;    return this.first+&quot; &quot;+this.last;&#125;function Person(first,last)&#123;    this.first=first;    this.last=last;    this.fullName=personFullName;&#125;</code></pre><pre><code class="js">function Person(first,last)&#123;    this.first=first;    this.last=last;&#125;var gha=new Person(ha,g);Person.prototype.fullName=function()&#123;    return this.first+&quot; &quot;+this.last;&#125;</code></pre><h3 id="网页事件"><a href="#网页事件" class="headerlink" title="网页事件"></a>网页事件</h3><p>可以采用匿名函数来实现</p><pre><code class="javascript">document.querySelector(&#39;html&#39;).onclick=function()&#123;    alert(&#39;2333&#39;);//alert弹出弹窗    var imge = document.querySelector(&#39;img&#39;);    let path=prompt(&quot;Input the picture&#39;s path you want!&quot;);//弹出一个输入框    imge.setAttribute(&#39;src&#39;, path);//设置元素src属性值为path    localStorage.setItem(&#39;localPath&#39;,path);//本地在浏览器中记录值，下次可以直接使用&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Introduction(2)</title>
      <link href="2021/08/24/cssnote(2)/"/>
      <url>2021/08/24/cssnote(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h2><h3 id="使用display控制布局"><a href="#使用display控制布局" class="headerlink" title="使用display控制布局"></a>使用display控制布局</h3><p>元素为块级元素以及行内元素，块级元素会占据尽可能多的宽度，而行内元素只占据必要的宽度。每一个元素有一个默认的display值，可以被样式的display值覆盖。</p><pre><code class="css">a &#123;    display:none;/*隐藏元素且不产生对应的空白 */&#125;</code></pre><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>position属性</p><p>设置位置：恒定在某个角落、滚动时移动但是会黏在上边界、静止不动</p><p>元素发生重叠时，用z-index指定图层的顺序</p><h3 id="元素溢出"><a href="#元素溢出" class="headerlink" title="元素溢出"></a>元素溢出</h3><p>文本超出长度，可以选择裁剪文本还是添加滚动条</p><h3 id="浮动和清除"><a href="#浮动和清除" class="headerlink" title="浮动和清除"></a>浮动和清除</h3><p>通过float来实现浮动，即类似于文字包围图片的效果。</p><p>有左、右、不、继承四个选项，设置在图片上。</p><p>通过clear可以实现不浮动，设置哪一侧可以有文字的浮动，设置在文字上。</p><h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><p>可以通过flex来实现</p><p>需要将元素的display指定为flex，该元素称为容器。</p><p>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p><p>容器有六个元素</p><ul><li>flex-direction 主轴方向</li><li>flex-wrap 项目排不下时是否换行</li><li>flex-flow 前两个的简写属性</li><li>justify-content 项目在主轴上的对齐方式</li><li>align-items 项目在交叉轴上的对齐方式</li><li>align-content 只有具有多根轴线的时候才起作用</li></ul><p>项目的属性</p><ul><li><code>order</code> 排列顺序、数字越小越靠前</li><li><code>flex-grow</code> 项目的放大比例</li><li><code>flex-shrink </code>项目的缩小比例</li><li><code>flex-basis </code>项目的原本大小</li><li><code>flex</code> 第二到第四个的简写</li><li><code>align-self </code>设置与其他元素不同的对齐方式，只对交叉轴有效</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://www.w3school.com.cn/css/index.asp">CSS 教程 (w3school.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Introduction</title>
      <link href="2021/08/24/cssnote/"/>
      <url>2021/08/24/cssnote/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS初探"><a href="#CSS初探" class="headerlink" title="CSS初探"></a>CSS初探</h2><p>CSS一般书写在HTML的头内 由&lt;style&gt;&lt;/style&gt;包括</p><p>CSS规则集：</p><pre><code class="css">h1 &#123;color:red;font-size:14px;&#125; /*h1 为选择器，指向对应元素，后面为声明块，一个属性和一个值 */</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器用于查找需要设置样式的HTML元素</p><p>分为五类：</p><ul><li>简单选择器 选择名称 id 类</li><li>组合器选择器 依据相互之间的关系（例如&lt;p&gt;下面的&lt;ul&gt;）</li><li>伪类选择器 依据特定状态选择</li><li>伪元素选择器 选择元素的一部分并设置样式</li><li>属性选择器 依据属性值或属性选择</li></ul><pre><code class="css">p &#123;    text-align:center;    color:red;&#125;/*元素选择器，含&lt;p&gt;标签的都收到影响*/#para1 &#123;    text-align:center;    color:red;&#125;/*id选择器 id必须唯一 且不能以数字开头 需要写#来标识是id选择器*/.crea &#123;    font-size: 15px;    color: blue;&#125;/*类选择器 需要加.来标识是类选择器*，类名不能以数字开头*/p.crea&#123;    font-size: 15px;    color: blue;&#125;/*复合选择器 可以选择两个条件的交集 HTML的元素可以引用多个类 实现多个类的效果*/* &#123;     font-size: 15px;/*15与像素单位之间不能有空格*/    color: blue;&#125;/*通用选择器 使用通配符来设置全体元素的样式*/h1,h2,p,.crea,para1&#123;     font-size: 15px;    color: blue;&#125;/*分组选择器 可以把多个组合并，可以合并类与id*//*以上代码为较简单的选择器*/</code></pre><h3 id="在HTML中添加CSS"><a href="#在HTML中添加CSS" class="headerlink" title="在HTML中添加CSS"></a>在HTML中添加CSS</h3><p>三种方法：</p><ul><li><p>外部</p><p>以外部文件形式存在，需在HTML文件内head内添加link</p><pre><code class="html">&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;src/css/headstyle.css&quot;&gt;    &lt;!-- rel为关系参数 有几个特定值  type由自己定义 描述类型 herf为资源的位置--&gt;&lt;/head&gt;</code></pre><p>其中src/css/headstyle.css应类似于如下（不包含任何html标签）</p><pre><code class="css">h1&#123;    font-size:15px;    color:blue;&#125;p&#123;    text-align:center;&#125;</code></pre></li><li><p>内部</p><p>即在head元素的style元素内定义</p></li><li><p>行内</p><p>直接在元素的标签内添加style属性</p><pre><code class="html">&lt;p style=&quot;color:blue;font-size:15px;&quot;&gt;233&lt;/p&gt;</code></pre></li></ul><p>多个样式表冲突时，使用最后定义的样式表</p><h3 id="CSS颜色"><a href="#CSS颜色" class="headerlink" title="CSS颜色"></a>CSS颜色</h3><p>背景色：background-color</p><p>文本色：color</p><p>边框色：border:2px solid blue;</p><p>可以使用rgb rgba 指定颜色，使用三个十进制数字或者是HEX值（三个16进制数，且以#开头）均可，a是不透明度</p><p>可以使用HSL值指定，为色轮上的着色</p><p>H:色相 0到360度 为不同颜色</p><p>S:饱和度 颜色的强度</p><p>L:亮度</p><p>HSL可扩展为hsla</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>background-color 背景颜色</li><li>background-image 背景图像</li><li>background-repeat 背景重复</li><li>background-attachment 背景的滚动与否</li><li>background-position 背景图像的开始位置</li></ul><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>可以设置圆角 宽度 样式 颜色等</p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>可以设置元素与周围其他元素的距离</p><p>可以利用百分比、绝对像素、自动、继承父元素等设置</p><p>外边距在某些情况下会自动发送合并</p><p>允许负值</p><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>会距边距大小自动调节边框大小</p><p>不允许负值</p><h3 id="宽度、高度"><a href="#宽度、高度" class="headerlink" title="宽度、高度"></a>宽度、高度</h3><p>设置的是包含外边距的区域宽度、高度</p><h3 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h3><p>即可以将内容包括在其中的一个框</p><pre><code class="css">div&#123;    width:200px;    padding:10px;    border:5px solid gray;    margin:0;    outline-style:dotted;/*轮廓、此处为点状轮廓*/&#125; /*盒元素*/</code></pre><p>轮廓有宽度、颜色、简写轮廓、轮廓偏移</p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code class="css">h1&#123;    color:#232323;    background-color:#FFFFFF;    text-align:left;/*水平对齐*/    direction:rtl;/*与下一条配合改变文本方向*/    unicode-bidi:bidi-override;/**/    vertical-align:top;/*垂直对齐*/    text-decoration:overline;/*装饰，包含下划线、横穿线、上划线*/    text-transform:uppercase;/*指定大小写*/    text-indent:50px;/*首行缩进*/    letter-spacing: 3px;/*字母间距、可以为负值*/&#125;</code></pre><p>还可以指定行高、词间距、空白处理方式、文字阴影（阴影颜色、模糊）、字体、字体样式（斜体、加粗、变体（变体将小写字母转换为同样大小的大写字母））、字体大小、</p><h3 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h3><p>使用font awesome网站</p><pre><code class="html">&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;&lt;/head&gt;&lt;!--引入图标--&gt;&lt;i class=&quot;fa fa-cloud&quot;&gt;&lt;/i&gt;&lt;!--在对应的名称前添加fa即可--&gt;&lt;i class=&quot;fa fa-cloud fa-lg&quot;&gt;&lt;/i&gt;&lt;!--图标变大--&gt;</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code class="css">/* 未被访问的链接 */a:link &#123;  color: red;&#125;/* 已被访问的链接 */a:visited &#123;  color: green;&#125;/* 将鼠标悬停在链接上 */a:hover &#123;  color: hotpink;&#125;/* 被选择的链接 */a:active &#123;  color: blue;&#125;</code></pre><p>可以用文本的装饰删除下划线、可以指定背景色</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>颜色、样式、迭代标记（数字、黑点还是字母）</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>边框、表格高度和宽度、水平对齐、垂直对齐、内边距、水平分割线、鼠标悬停效果、斑马纹效果、背景颜色、文本颜色、响应式表格（出现滚动条）</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.w3school.com.cn/css/index.asp">CSS 教程 (w3school.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL初探</title>
      <link href="2021/08/22/SQL/"/>
      <url>2021/08/22/SQL/</url>
      
        <content type="html"><![CDATA[<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>合适位置建立数据库，在命令行操作</p><pre><code class="shell">sqlite3 db.sqlite3  #建立或加载数据库 CURD为增删查改四种基本操作，进入数据库需要先载入数据库#查select * from student; #需要分号 从表中查找select id, name from student where sex=&#39;男&#39; and age &lt;= 22;  #精细查找名称、学号#增insert into student values (123, &quot;test1&quot;, &quot;男&quot;,22,&#39;毕业生&#39;); #不区分单双引号insert into student (id,name,age) values (233,&quot;&quot;,23),(345,&quot;?&quot;,33); #插入特定信息，未定义使用默认值，未显式定义默认值则为NULL</code></pre><p>删除</p><pre><code class="shell">delete from student where age =18; #查询不到对应条件也无回应</code></pre><p>更新</p><pre><code class="shell">update student set age = 30 where id = 123;update student set age=age+1 where id =123;</code></pre><p>创建表</p><pre><code>create table teacher(    id int primary key not NULL,    name varchar(32),    sex varchar(2),    age int,    status varchar(8));</code></pre><p>​    其他</p><pre><code class="shell">.help #帮助.quit #退出.tables #列出所有表名.schema &lt;table_name&gt; #查看表的schema信息</code></pre><p>SQLite不具备很好的并发性，不能在高并发的网站中使用，不能同时做许多操作</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>搭建非静态网站，一般MySQL 或 MariaDB是首选 使用Docker来降低配置环境的成本。</p><h3 id="python交互SQLite"><a href="#python交互SQLite" class="headerlink" title="python交互SQLite"></a>python交互SQLite</h3><pre><code class="python">DATABASE_URL = &quot;sqlite:///./Data.db&quot; #数据库存放的地址engine=create_engine(DATABASE_URL) #引擎连接数据库DBSession=sessionmaker(bind=engine) #依据引擎创造会话Base=declarative_base() #数据库的Base类#以下为创建表单class Worker(Base):    __tablename__=&#39;worker&#39; #表的名称，单双引号不分    id=Column(Integer,primary_key=True) #创建关键字段为id 类型为int    record=relationship(&#39;Record&#39;,back_populates=&quot;worker&quot;)#创建外键，以一对多连接记录,worker为record记录里的worker    class Record(Base):    __tablename__=&#39;record&#39;     id=Column(Integer,primary_key=True,autoincrement=True,nullable=False) #设置id自动增加，每条新纪录+1    worker=relationship(&quot;Worker&quot;,back_populates=&quot;record&quot;)    worker_id=Column(Integer,ForeignKey(&quot;Work.id&quot;))#绑定多方外键、使用类名    time=Column(Integer)Base.metadata.create_all(bind=engine) #在数据库中创建上述没有的表单new_worker=Worker(    id=2,)new_record=Record(    time=1,)db=DBSession() #创建一个会话db.add(new_worker) #添加工人db.add(new_record) #添加记录new_record.worker=new_worker #绑定工人和记录db.commit() #提交操作db.close() #关闭会话</code></pre><h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三系暑培笔记</title>
      <link href="2021/08/05/note_of_summer_trainning/"/>
      <url>2021/08/05/note_of_summer_trainning/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="C-与-net"><a href="#C-与-net" class="headerlink" title="C#与.net"></a>C#与.net</h3><p>C#：编译产生微软中间语言（MSIL）而非直接由OS执行的机器码</p><p>.net框架：将C#编译产生的微软中间语言翻译成为可以让OS执行的机器语言，作为交互媒介</p><p>CLR（公共语言运行库）：是.net框架的核心，作为与程序员交互的平台，不需要再深究内存分配与释放的问题</p><p>通过CLR的操作系统适配，使得MSIL能够跨平台</p><p>.net有很多的版本</p><h3 id="net的版本"><a href="#net的版本" class="headerlink" title=".net的版本"></a>.net的版本</h3><p>最初的版本：.net framework 不能跨平台（民间产出了类似的的跨平台CLR Mono）</p><p>后来版 .net core 可以跨平台</p><p>当core功能齐全之后，改名为.net 5</p><p>为了统一.net运行时的标准，微软产出了.net standard</p><h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><p>排行榜上万年老五，运行在.net上，语法丰富，代码量少</p><p>桌面开发(GUI开发类似于QT)：Winform, WPF</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程产生的资源竞争的问题</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>HTML(标记语言描述网页的元素)</p><p>CSS 如何装饰HTML</p><p>JavaScript添加动态功能</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>核心概念是：镜像（和容器相似，但不能操作）、容器（一种进程，被隔离的进程）、仓库</p><p>镜像与容器类似于C++类和对象的关系</p><p>docker可以把应用及其依赖的环境打包成一个镜像，来直接部署，用镜像生成一个容器，可以节省配置环境的工作</p><h3 id="JavaScript-TypeScript-NodeJs"><a href="#JavaScript-TypeScript-NodeJs" class="headerlink" title="JavaScript TypeScript NodeJs"></a>JavaScript TypeScript NodeJs</h3><p>Js与java无关，与python更为相似</p><p>js是一种动态类型的解释性的脚本语言</p><p>ECMA是JS的一个标准</p><p>TypeScript是JS的超集，提供了固定类型</p><p>NodeJs是JS的一个非浏览器运行环境</p><p>npm yarn是包管理工具</p><h3 id="React开发框架"><a href="#React开发框架" class="headerlink" title="React开发框架"></a>React开发框架</h3><p>用来搭建前端</p><h3 id="数据库-Hasura"><a href="#数据库-Hasura" class="headerlink" title="数据库 Hasura"></a>数据库 Hasura</h3><p>restful api 与 Graphql</p><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>七层模型，最上面三层合并为一层，最终有五层</p><p>应用层</p><p>传输层：端到端，处理丢包 使用TCP（可靠 但是慢） UDP（快 不可靠） 用来处理多发漏发串码的问题</p><p>网络层：IP协议层 网络分布</p><p>数据链路层：</p><p>物理层</p><p>Socket（套接字）：</p><p>第三方库：HP SOCKET 可以粘包 加快开发速率</p><p>Protobuf</p><h3 id="Web全栈开发"><a href="#Web全栈开发" class="headerlink" title="Web全栈开发"></a>Web全栈开发</h3><p>前端：</p><p>后端：</p><p>数据库：</p><p>应用部署：</p><p>SCSS Webpack 用户体验</p><p>Vue</p><p>express caddy</p><p>云服务入门：CDN(内容分发网络) OSS</p><p>微信公众号后台：express-wx</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h4><p>深度学习框架，前向传播，反向传播，计算梯度，需要再GPU上跑</p><h4 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h4><p>硬件开发平台</p><h4 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h4><p>硬件描述语言，将逻辑翻译为电路</p><h4 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h4><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>gitbash的使用：</p><pre><code>git add readme.txt  添加文件到暂存区git commit -m &quot;message&quot; 将暂存区的修改添加到仓库内git remote add &lt;name&gt; &lt;address&gt; 添加远程仓库git remote -v 查看远程库信息git remote rm &lt;name&gt; 解除绑定</code></pre><h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>程序是软件，输入是键盘或鼠标，输出是显示器</p><p>GUI程序，有CUI的程序成为GUI应用‘</p><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>OS下面是硬件、上面是各种应用程序。输入输出先到达OS，再转交给对应的应用程序；输出先交给OS再反馈给用户。能用鼠标点击，出现图像的是GUI系统。</p><h4 id="文件、路径"><a href="#文件、路径" class="headerlink" title="文件、路径"></a>文件、路径</h4><p>机械硬盘：磁介质的两种磁化方式对应0、1；SSD电容充放电对应0、1；</p><p>纯文本文件，内部是直接的内容编码；</p><p>大多数与文字相关的文件是纯文本文件；.c .h .cpp .py .html .xml 以及一些配置文件和不带后缀的文件都是纯文本文件。打开纯文本文件需要一个能读懂编码的程序，成为文本编辑器。</p><p>媒体文件：类似于图片、音乐、压缩包；需要约定如何打开这些文件，需要专门软件来解析。</p><p>后缀名决定打开方式，后缀名是文件名的一部分。</p><p>程序（机器指令）本身也是0、1文件</p><p>计算机内的文件只分为这三类。</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>资源管理器：看文件的软件</p><p>文件系统是树状的层级结构，每一个文件都有一个路径。</p><p>绝对路径：从硬盘开始</p><p>LINUX的绝对路径：/users/../../.. 第一个/是根目录，就是硬盘；linux的根目录是硬盘</p><p>家目录：家目录是每个用户各自的文件夹，用<del>代替家目录；</del>/wxy/桌面</p><p>相对路径：已经有一个目录，再去描述目标文件的路径；.指当前文件夹，..指上级文件夹，../..指上上级文件夹</p><p>隐藏文件：一般是以.开头的文件和文件夹，还有一些其他文件也被隐藏。隐藏文件一般比较核心。</p><p>bin文件夹一般指 binary二进制，其中是一些可执行程序（？）</p><h3 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h3><h4 id="终端和SHELL"><a href="#终端和SHELL" class="headerlink" title="终端和SHELL"></a>终端和SHELL</h4><p>终端是黑窗口，是一个应用程序；可以开启多个SHELL(一个标签页)</p><p>Shell的功能是解析输入的命令：（通过空格来分割程序和参数）</p><ol><li><p>通过绝对路径来打开应用程序（以date文件为例，参数-r 可以接数字和文件名）</p></li><li><p>通过命令让shell来解析要调用的程序，例如输入date可以直接调用程序；shell的作用是解析字符串，它会在环境变量中寻找字符串对应的程序。环境变量是一系列存放命令行程序的文件夹</p><p>bin就是一个环境变量；这些单个的单词称作命令；又是也将整个一行称为命令，本质上是调用程序并且提供输入/参数；能用命令直接调用的程序称之为命令行程序</p></li><li><p>自己书写命令行程序</p><p>常用的shell命令</p><pre><code class="shell">与工作路径有关pwd 显示当前路径cd 更换路径至后面的参数ls 列出当前目录所有文件和文件夹ll 或 ls -l与文件操作有关mkdir 创建新文件夹rm 删除文件rm -d 删除空文件夹rm -rf 删除文件夹mv 移动文件cp 复制文件find 查找文件与纯文本相关vim touch 新建文本文件cat &lt;file&gt; 查看文件内容head &lt;file&gt; 查看文件的前十行与命令相关clear 清空终端history 查看历史命令man 查看某个命令的手册xx --help (-h) 查看摸一个命令行程序的帮助与进程相关ps 查看当前进程kill 向进程发生一些信号</code></pre></li><li><p>命令行的文本编辑器vim</p><p>按i进入编辑模式，按esc退出编辑模式，按:输入编辑器的选项，用wp保存退出，cat可以查看；<a href="%5Bvim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_yxj%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_45379253/article/details/115872968)">更多指令</a></p></li><li><p>用g++编译链接文件，生成可执行文件</p></li><li><p>其他shell操作</p><pre><code class="shell">which shell如何解析输入where 可能如何解析命令grep 字符串搜索，可以用正则表达式输入输出流重定向例：touch my.txtecho &quot;hello world&quot; &gt; my.txt # 将输出覆盖到文件echo &quot;hhhh&quot; &gt; my.txt # 将输出覆盖到文件echo &quot;hahahaha&quot; &gt;&gt; my.txt # 将输出追加到文件mkdir ha/haha 2&gt; /dev/null # 忽略错误mkdir ha/haha 2&gt;&gt; error.log # 追加错误到日志文件中&gt;：输出重定向到一个文件或设备 覆盖原来的文件&gt;!：输出重定向到一个文件或设备 强制覆盖原来的文件&gt;&gt;：输出重定向到一个文件或设备 追加原来的文件&lt;：输入重定向到一个程序（如果你要做数算题，输入数据的时候可能会用到）注：这里文件指的是纯文本文件；设备中有一个比较特殊的是/dev/null，如果你不需要输出的信息，你可以将信息重定向到这里输入和输出表示：主要有三种输出入的状况，分别是：标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt;标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt;错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt;管道：上一个命令的输出作为下一个命令的输入 |左边是上一个命令，右边是下一个命令</code></pre><pre><code class="shell">^c #即ctrl+c 结束当前的程序，或者重新输入命令^d #退出一个shell#部分符号需要反转译#通配符 * #匹配多个字符? #匹配单个字符tab 和右键补全（需要个性化配置）#文件夹和文件权限ll #查看文件类型 十位数字chmod #更改权限</code></pre></li></ol><h3 id="shell脚本（以sh作为后缀名）"><a href="#shell脚本（以sh作为后缀名）" class="headerlink" title="shell脚本（以sh作为后缀名）"></a>shell脚本（以sh作为后缀名）</h3><p>脚本：一种描述性语言，是一种可执行文件。本质上是一种纯文本文件，需要解释器（例如shell 或者python）来执行。</p><p>比较难写</p><h3 id="shell配置文件"><a href="#shell配置文件" class="headerlink" title="shell配置文件"></a>shell配置文件</h3><p>zsh配置文件 ~/.zshrc</p><p>bash配置文件 .bash_profile</p><p>推荐 missing semester</p><h3 id="命令行与GUI"><a href="#命令行与GUI" class="headerlink" title="命令行与GUI"></a>命令行与GUI</h3><p>GUI操作方便，但是占用资源非常多；最常见的只有命令行的操作系统是LINUX</p><h3 id="linux历史"><a href="#linux历史" class="headerlink" title="linux历史"></a>linux历史</h3><p>LINUX初衷是替代UNIX，现在的许多OS都是类unix系统</p><p>LINUX内核是开源的</p><p>LINUX发行版本：一些组织或厂商将LINUX内核与各种软件、文档包装起来，提供一些安装界面和系统配置等等；常见的有：ubuntu、CentOS</p><p>平时使用的说的都是LINUX的发行版</p><h3 id="LINUX文件系统"><a href="#LINUX文件系统" class="headerlink" title="LINUX文件系统"></a>LINUX文件系统</h3><p> Linux中，一切皆文件，文件、目录、管道、通配符都是文件</p><h3 id="上手linux"><a href="#上手linux" class="headerlink" title="上手linux"></a>上手linux</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>SSH远程链接</p><h4 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h4><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>虚拟机可以模拟出硬件，在硬件上跑其他的操作系统</p><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>和虚拟机差不多，占用的资源更少，效率更高</p><h4 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h4><h4 id="云端服务器的功能"><a href="#云端服务器的功能" class="headerlink" title="云端服务器的功能"></a>云端服务器的功能</h4><p>处理请求 == 提供服务，处理多人发的请求的机器就是服务器；一般来说，一个端口对应一个服务</p><h4 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h4><p>LINUX上的包管理器是APT</p><h4 id="部署可以交互的小游戏"><a href="#部署可以交互的小游戏" class="headerlink" title="部署可以交互的小游戏"></a>部署可以交互的小游戏</h4><h4 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h4><p>当终止远程链接时，希望服务器上的程序能够继续运行，需要使用tmux</p><h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><p>GIT与GITHUB不同，GIT本身的源代码是开放的</p><p>安装后设置git config的–global参数，只用设置一次</p><pre><code class="shell">git init #初始化一个仓库git add &lt;file&gt; # 添加文件到仓库git status #提交状态git commit -m &quot;message&quot; #提交当前的暂存区，标注为message#若没有输入-m，会进入指定的编辑器（命令行EDITOR环境变量指定）#-m 提交信息有着一定的规则</code></pre><p>.gitignore文件中声明的文件和文件夹，文件类型</p><pre><code class="shell">/node_/ #忽略整个文件夹*.cpp #忽略某种类型的文件、采用通配符/node2/a.h #忽略某个具体文件，写相对路径#可以增加!反向限制，即不忽略某个文件</code></pre><p>版本回退</p><pre><code class="shell">git log #显示日志git reset #回退版本git checkout -- &lt;file&gt; #撤销暂存区的修改git rm &lt;file&gt; #删除仓库里的某个文件</code></pre><p>远程仓库</p><pre><code class="shell">git remote add origin &lt;name&gt; #关联远程仓库git remote rm &lt;name&gt; #解除关联git remote -v #查看远程库信息git push &lt;remote name&gt; &lt;branch&gt; #推送修改git fetch &lt;remote name&gt; &lt;branch&gt; #拉取代码到本地仓库git merge &lt;branch&gt; #合并目标分支到当前分支git clone #克隆远程分支到本地</code></pre><p>分支管理</p><pre><code class="shell">git branch #显示所有分支git branch &lt;name&gt; #以当前分支创建新分支git checkout &lt;name&gt; #切换分支至git branch -d &lt;name&gt; #删除分支git merge &lt;name&gt; #合并分支</code></pre><p>合并冲突</p><pre><code class="shell">#需要手动修复冲突</code></pre><h2 id="GITHUB-ACTION"><a href="#GITHUB-ACTION" class="headerlink" title="GITHUB ACTION"></a>GITHUB ACTION</h2><p>CI/CD</p><h3 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h3><p>使用pep8(for python), eslint(for ECMAScript)进行代码格式化</p><h4 id="Linter"><a href="#Linter" class="headerlink" title="Linter"></a>Linter</h4><p>代码高亮</p><h4 id="单元测试以及集成测试"><a href="#单元测试以及集成测试" class="headerlink" title="单元测试以及集成测试"></a>单元测试以及集成测试</h4><p>每个函数的测试（类似OJ）、函数组合功能的测试以及代码覆盖率（测试用到的代码占比）</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>​        CI机器自动构建</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h2><pre><code class="shell">dotnet new console --output hello #创建一个程序dotnet new --list #查看可以创建的项目类型dotnet run --project &lt;name&gt; #运行</code></pre><p>类型：</p><ol><li>值类型<ol><li>结构类型</li><li>枚举类型</li></ol></li><li>引用类型</li></ol><p>object是所有类型的基类，是引用类型，其句柄可以指向所有类型</p><p>对值类型的指向需要装箱、拆箱操作</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是一个类类型，为引用类型，支持UTF-8</p><p>字符串文本，用双引号括起来</p><p>逐字字符@开头，双引号引起，不需要转移，但是不能含双引号</p><p>可以插入变量，需要$开头，变量用花括号包含</p><p>自动推导类型 ver 关键字</p><p>值类型赋值，引用类型是更改句柄指向</p><p>可以在关键字前添加 @ 来使用关键字作为变量名，会自动忽略@</p><p>C#会自动垃圾回收，不需要手动delete堆内存</p><h3 id="C-入门"><a href="#C-入门" class="headerlink" title="C#入门"></a>C#入门</h3><p>输入输出</p><p>输出：</p><pre><code class="c#">System.Console.Write(&quot;&quot;);System.Console.Writeline(&quot;&quot;); //附带一个换行//可以格式化输出</code></pre><p>输入</p><pre><code class="c#">system.console.read(); //读入一个字符并返回intsystem.console.readline(); //读入一行字符串//类型转换system.convert.to...、、、//利用好自动补全进行转换</code></pre><p>运算符：算数运算符、逻辑运算符、位运算符、三目运算符与C++一致</p><ul><li>？运算符 检查一个句柄是否为NULL</li><li>?? </li><li>??= </li></ul><p>控制结构，与C相同</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>引用类型，需要new出来</p><p>角标访问，length获取长度</p><p>foreach 关键字遍历元素</p><p>二维数组 arr[,] length是总长，getlength(i) 是i+1维的长度</p><p>交错数组 int [] [] arr</p><h3 id="C-面向对象初步"><a href="#C-面向对象初步" class="headerlink" title="C#面向对象初步"></a>C#面向对象初步</h3><pre><code class="c#">class ClassName&#123;    public int x;    public int y;//每一行（每一个字段）都需要权限限制，字段习惯小驼峰命名法    public static int mn;//静态字段，需要用类名.字段名访问&#125;//习惯用大驼峰命名法，每一个单词的首字母大写；附：小驼峰命名法，首字母不大写，其他一致</code></pre><p>方法（即函数）</p><p>返回值、方法名、参数列表合成为方法的签名，方法习惯大驼峰，静态方法</p><p>方法的参数传递：值类型赋值（若想传入引用，需要在参数列表以及调用处加上关键字 ref），引用类型传入句柄</p><p>函数缺省值</p><p>构造方法无返回值类型，与C++相同，只是不能有初始化列表</p><p>简短函数可以用 =&gt;来直接返回</p><p>方法重载，参数列表不同即可</p><p>运算符重载必须是静态方法，可重载的运算符较少</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>一个属性包含两个部分：</p><ol><li>get 访问器 外部读取字段值</li><li>set访问器 外部设置字段值</li></ol><p>一般字段私有，绑定到公有的属性</p><p>一般使用时，只定义属性，让编辑器自动生成对应的私有字段，可以有默认值</p><h3 id="只读字段"><a href="#只读字段" class="headerlink" title="只读字段"></a>只读字段</h3><p>只能在构造方法里被赋值 readonly 关键字</p><p>将set 改为init 可以将属性只读化</p><p>类和嵌套类 protected 权限 只有外部类的派生类能看到</p><p>partial 类 可以分成几部分定义</p><p>继承没有权限的问题，不需要限制public继承，一个类有且只能有一个基类</p><p>为基类提供构造参数通过初始化列表</p><p>密封类sealed 关键字，密封类不能再被继承</p><h4 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h4><p>变量 is 类型  返回布尔值</p><p>is not 相反</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>抽象类 abstract 关键字，可以定义抽象类、抽象方法</p><p>虚方法需要加上 virtual关键字</p><p>虚方法必须定义函数体，抽象方法不能定义函数体，抽象方法必须写在抽象类当中</p><p>重写覆盖需要 override关键字</p><p>属性也可以定义为虚的和抽象的</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口属于引用类型，是没有字段只有方法的类，需要用interface而不是class定义</p><p>命名一般采用大驼峰，且以大写字母I开头</p><p>一个类可以继承多个接口，接口内方法的权限默认是public</p><p>接口可以定义属性</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>只需要在类或者方法后加上&lt;T&gt;即可</p><p>可以对泛型进行约束 where关键字</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托是一种引用类型，与函数指针类似，需要delegate关键字</p><pre><code class="c#">delegate int BinaryFuntor(int x,int y); //定义委托类int Add(int a.int b) =&gt; a+b;BinaryFuntor add = new BinaryFuntor(Add);//构建句柄</code></pre><p>内置委托 action func</p><p>委托函数 多播委托 可以用+来增加多个方法</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>（参数列表）=&gt; 返回值</p><p>（参数列表）=&gt; {返回语句}</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是一种委托</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="可为空的类型"><a href="#可为空的类型" class="headerlink" title="可为空的类型"></a>可为空的类型</h4><p>int?  即正常的int类型，同时支持赋值为null</p><p>可为空的值类型与不可为空的值类型不是同一个类型 int? int 不同</p><p>而可为空与不可为空的引用类型是同一个类型</p><h3 id="托管与垃圾回收"><a href="#托管与垃圾回收" class="headerlink" title="托管与垃圾回收"></a>托管与垃圾回收</h3><p>GC 垃圾回收机制</p><p>终结器  （析构函数）</p><p>非托管资源</p><p>语言继承查询</p><h2 id="多线程与异步"><a href="#多线程与异步" class="headerlink" title="多线程与异步"></a>多线程与异步</h2><p>计算机架构：冯诺依曼架构、哈佛结构</p><p>CPU架构： PC x86; pe arm; mips ;risc-v</p><p>操作系统：内核、shell、GUI</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的一个被隔离的单独的程序就是一个“进程”。</p><p>虚拟内存：每个进程在运行时都被分配了一块虚拟的内存</p><p>进程的三个状态：</p><ol><li>运行态 正在吃</li><li>就绪态 饿了等着拿到筷子</li><li>阻塞态 等着上桌</li></ol><p>进程的调度：轮流安排多个进程并行地执行</p><p>上下文切换：记录进程停止时的状态，切换为另一个进程的状态</p><p>linux进程： ps 命令；kill 可以杀死进程</p><p>前台进程占据当前SHELL,后台进程不占用，创建后台进程需要在后面加上&amp;,使用jobs可以查看当前的所有后台进程，使用fg可以将后台进程转换至前台</p><p>对LINUX C++进程的函数为</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在一个进程内同时运行多个线程，不同线程之前可以共享资源</p><h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><p>pthread.h头文件C++</p><p>C#中的线程库 Thread类</p><p>C#线程分为前台线程、后台线程</p><p>前台线程会阻塞整个程序的退出，后台线程则会在整个程序退出时自动结束</p><p>默认情况下是前台线程，可以改为后台线程</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>预先开辟多个线程、然后等需要的时候，直接使用已经创建好的线程以减少开销</p><p>一般情况下使用封装好的task timer等间接使用线程池</p><h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><ul><li>传递信息：<ul><li>套接字</li><li>管道</li></ul></li><li>资源竞争</li><li>顺序的正确性</li></ul><h4 id="原子操作（原语）"><a href="#原子操作（原语）" class="headerlink" title="原子操作（原语）"></a>原子操作（原语）</h4><p>原子操作：不可再分的操作</p><p>为了防止线程切换时打断某些复杂操作，使得部分简单步骤丢失，引入原子操作；即每一次对线程的打断保证刚刚执行的操作被完全进行完毕。</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>资源竞争问题，将共享的资源、数据片段称为临界区，要求两个线程不能同时进入临界区，要求：</p><ol><li>任何两个进程不能同时进入临界区</li><li>对CPU的速度、数量没有要求</li><li>临界区外运行的进程不能阻塞到其他进程</li><li>不能让一个进程无限期等待进入临界区</li></ol><p>忙等待：一直进行判断，尽量避免忙等待</p><p>忙等待的方法，不好！</p><p>休眠与唤醒方法：</p><p>当进程无法进入临界区时，让进程睡眠，进程退出临界区时，唤醒另一个进程</p><p>也不太好</p><p>信号量的方法：（正确解法）</p><p>一个信号量含一个整数来计数（资源总量），以及两个原子操作，即把睡眠唤醒方法的判断和睡眠两个操作合为一个，把判断和唤醒合为一个</p><p>分为P操作、V操作</p><p>信号量可以解决生产者——消费者问题</p><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>信号量的初始值为1，称为互斥量，P称为加锁，V称为解锁</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>与互斥量配合使用，在互斥量已经加锁的条件下，条件变量的基本操作有三个：</p><ol><li>解锁并开始休眠</li><li>唤醒一个进程</li><li>唤醒所有进程</li></ol><p>存在的问题：信号丢失、虚唤醒</p><h3 id="c-的支持"><a href="#c-的支持" class="headerlink" title="c#的支持"></a>c#的支持</h3><p>system.threading.semaphore</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁一般与资源的获取有关</p><p>死锁：两个进程想要对方的资源，又都不愿意释放</p><p>处理方法：破坏死锁的形成条件四者之一</p><h3 id="其他经典IPC问题"><a href="#其他经典IPC问题" class="headerlink" title="其他经典IPC问题"></a>其他经典IPC问题</h3><ul><li>哲学家就餐<ul><li>编号，一个人先拿左边再拿右边，其他人先拿右边，再拿左边</li></ul></li><li>读者-写者问题（多个进程读，只能一个进程写且不能同时读）<ul><li>读者优先</li><li>由于过于复杂，大多数语言提供了读写锁</li></ul></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="TASK"><a href="#TASK" class="headerlink" title="TASK"></a>TASK</h4><p>创建task System.Treading.Tasks内的task类</p><h2 id="Winform"><a href="#Winform" class="headerlink" title="Winform"></a>Winform</h2><p>常用控件</p><ul><li>labal 显示静态文本</li><li>Textbox 支持输入文本</li><li>Button 触发事件 IDE内双击生成事件函数</li></ul><p>可以手工添加控件</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>Anchor: 锚定到边远</p><p>dock: 停靠到边远</p><p>用panel进行布局</p><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p>为事件指定回调函数</p><p>对按钮来说，可以在设计器里双击</p><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>去窗口上手动绘制交互界面</p><p>使用窗口的paint事件</p><p>绘图在最底层显示</p><h3 id="玩玩就好，不太好用"><a href="#玩玩就好，不太好用" class="headerlink" title="玩玩就好，不太好用"></a>玩玩就好，不太好用</h3><h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><p>XMAL：描述性语言</p><p>APP是逻辑，入口</p><p>MainWindow是窗口</p><h3 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h3><p>使用Stackpanel容器来布局，单向排列，超出不会显示</p><p>WrapPanel:支持换行换列</p><p>DockPanel：最常使用，</p><h3 id="控件（control）"><a href="#控件（control）" class="headerlink" title="控件（control）"></a>控件（control）</h3><p>三种：</p><ul><li>ContentControl</li><li>ItemControl</li><li>TextBoxBAse</li></ul><p>控件之间可以相互嵌套</p><p>提倡数据系统</p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>字体的颜色、大小、边距、位置，作为预先设计好的外观</p><p>推荐写入application resources</p><p>触发器：类似于事件</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>控件模板</li><li>数据模板</li></ul><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>Binding 元素绑定到控件的元素</p><p>绑定至context</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>分离界面与后台逻辑代码，利用数据绑定函数</p><h4 id="prism"><a href="#prism" class="headerlink" title="prism"></a>prism</h4><p>案例分析：下载器</p><h2 id="JS-TS-yarn-NodeJS"><a href="#JS-TS-yarn-NodeJS" class="headerlink" title="JS TS yarn NodeJS"></a>JS TS yarn NodeJS</h2><p>Js解释型的脚本语言，在cmd中node启动node.js</p><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>可以用中文作为变量名，动态类型，可以保存不同类型的数据</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>**求幂 === 数值、类型均相同、一元的+运算符、字符串＋直接链接字符串</p><p>解构操作：</p><pre><code class="js">[a,b,...rest]=[1,2,3,4,5]rest=[3,4,5]...rest=3,4,5</code></pre><p>控制结构</p><p>for的三种用法</p><p>函数</p><p>使用function关键字，也可以lambda表达式</p><p>arguments对象：函数参数的储存数组</p><p>剩余参数：允许将不确定数量的参数表示为数组</p><pre><code class="javascript">function multiply(factor,...theArgs)&#123;    return theArgs.map((x)=&gt;factor*x);&#125;console.log(multiply(3,4,5,1,2,3));//从第二个参数开始作为一个数组</code></pre><p>对象：名称-值对</p><pre><code class="js">var obj=&#123;&#125;;var obj2=&#123;    age:15,    name:&quot;adawd&quot;,//注意逗号&#125;obj2.name;Object.keys(obj2);//Array对象forEach();//map//reduce()//Proxyconst p = new Proxy(target,handler);//target是被隐藏权限的对象var handler=&#123;    get:function(obj,prop)&#123;        return prop in obj? obj[prop]:&quot;NULL!&quot;;    &#125;,    set:function(obj,prop,value)&#123;        obj[prop]=value;    &#125;,&#125;;var person=&#123;    name:&quot;2333&quot;,    age:25,&#125;var p =new Proxy(person,handler);//固定是handler,需要重载它的内置方法，还有get,set之外的属性console.log(p);p.name=&quot;awdawfa&quot;;</code></pre><p>异常处理</p><pre><code class="js">//throw语句扔出异常//try...catch语句捕获//有异常会执行catch的语句，否则不执行//最后可以跟上finally语句，总会执行function getm(mo)&#123;    mo=mo-1;    var months=[        1,        2,        3,        4,        5,        6,        7,        8,        9,        10,        11,        12,    ];    if(months[mo])&#123;        return months[mo];    &#125;else&#123;        throw &quot;223&quot;;    &#125;&#125;try&#123;    m=getm(15);&#125;catch(e)&#123;    m=&quot;unknown&quot;;    console.error(e);&#125;finally&#123;    console.log(m);    console.log(&quot;done!&quot;);&#125;</code></pre><p>模块（类似于python）import导入</p><p>异步和阻塞</p><pre><code class="js">//异步回调setTimeout(()=&gt;&#123;    console.log(&quot;hi&quot;);&#125;,20000);console.log(&quot;bye&quot;);//使用回调函数实现异步//Promisefetch(url)    .then(console.log(&quot;a&quot;))    .then(console.log(&quot;b&quot;))    .catch(console.log(err))    .finally&#123;        console.log(&quot;ok&quot;)    &#125;;//fetch返回一个promise，promise.then()会返回一个promise，then()包含一个回调函数，接收前一步的结果作为输入//async/await语法糖let hello = async()=&gt;&#123;//async关键字将函数变为异步函数，添加promise对象    return &quot;2333&quot;;&#125;hello().then((a)=&gt;&#123;    console.log(a+a);&#125;);console.log(hello());//使用await版本let hello = async()=&gt;&#123;//async关键字将函数变为异步函数，添加promise对象    return &quot;2333&quot;;&#125;async function deal()&#123;    var a=await hello();//即先阻塞这个函数，等await后部分执行完毕后再继续执行    console.log(a);&#125;deal();</code></pre><h4 id="文档MDN"><a href="#文档MDN" class="headerlink" title="文档MDN"></a>文档MDN</h4><h3 id="npm-yarn"><a href="#npm-yarn" class="headerlink" title="npm yarn"></a>npm yarn</h3><p>包管理工具</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>强类型的js改版，需要安装typescript包</p><p>tsc –init 来初始化生成json文件</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>一种罗列元素的语言</p><p>元素</p><pre><code class="html">&lt;h1&gt;233&lt;/h1&gt;&lt;p&gt;adaw&lt;/p&gt;&lt;em&gt;aaa&lt;/em&gt;&lt;strong&gt;标签可以嵌套&lt;/strong&gt;</code></pre><p>块级元素：相对于前面元素会出现在新的一行</p><p>内联元素：出现在一堆块级元素之间</p><p>空元素：一些元素只有一个标签，没有结束标签</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>基本写法</p><pre><code class="html">&lt;p class=&quot;foobar&quot;&gt;    2333&lt;/p&gt;</code></pre><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>声明类型</li><li>html元素</li><li>head元素</li><li>&lt;meta charset=”utf-8”&gt;：元数据</li><li>title元素</li><li>body元素</li></ul><h3 id="在html中应用css和js"><a href="#在html中应用css和js" class="headerlink" title="在html中应用css和js"></a>在html中应用css和js</h3><p>CSS：样式语言</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;./main/my.css&quot;/&gt; 引入样式，一般放在head里或者写在元素里&lt;script src=&quot;./main/my.js&quot;&gt;&lt;/script&gt; 一般放在结尾的&lt;/head&gt;前</code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>一门给予规则的语言：由一个选择器开头，后接一对大括号，在大括号里定义一个或多个属性，定义样式</p><p>元素选择器，匹配对应的元素，不同的选择器可以放在一起；元素选择器比较笼统</p><p>单独选择一个元素可以定义类</p><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><h2 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h2><p>正则表达式爬取</p><h2 id="JS-TS实现交互"><a href="#JS-TS实现交互" class="headerlink" title="JS TS实现交互"></a>JS TS实现交互</h2><p>DOM</p><h2 id="SCSS-Sass"><a href="#SCSS-Sass" class="headerlink" title="SCSS/Sass"></a>SCSS/Sass</h2><p>CSS的预处理器，独特的语法来生成CSS的程序</p><p>node 或者 yarn 安装 sass安装包</p><pre><code class="bash">sass input.scss output.css #单文件转换命令sass --watch input.scss:output.css #单文件监听命令，监听：源文件更改后自动编译sass --watch app/sass:public/stylesheets #监听整个目录</code></pre><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><pre><code class="scss">//变量$age: 4;$color: #333;//一个变量可以引用另一个变量//作用域为大括号//选择器可以嵌套，父选择器&amp;，属性名可以嵌套//交互式命令行sass -i;@debug a;//输出a@use &#39;base&#39;; //引入模块base.css//混入器，类似于宏@mixin;//占位符类//支持运算符//插值，可以在选择器或者实行名中使用变量、//条件控制，循环，下标从1开始，函数//内置模块</code></pre><h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><p>不涉及代码</p><h3 id="平面设计基础"><a href="#平面设计基础" class="headerlink" title="平面设计基础"></a>平面设计基础</h3><p>排布页面：</p><ul><li>少即是多 有序整齐<ul><li>字体种类要少一点，色彩要少，减少艺术字效果，字号少，对齐线，学会留白</li></ul></li><li>对齐和网格，格栅</li><li>信息组织<ul><li>相关分类</li><li>相同——对比</li><li>层级信息</li><li>主次关系</li></ul></li><li>用图说话  <a href="Thenounproject.com">图标网站</a></li></ul><h3 id="界面交互"><a href="#界面交互" class="headerlink" title="界面交互"></a>界面交互</h3><p>Adobe XD 交互界面设计软件</p><ul><li>设计统一，设计标准</li></ul><p>ant design组件库 中文文档</p><p>组件色彩</p><p>网格布局、格栅：列和沟 列起列收</p><p>一般宽长比为8:4的倍数</p><h3 id="交互认知"><a href="#交互认知" class="headerlink" title="交互认知"></a>交互认知</h3><p>位置定位 按钮反馈</p><p>动态效果</p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>前端：PHP Js jQuery库 </p><p>jQurey库 插件一般放在结尾之前 很过时</p><p>构建工具：Bundler  简化代码，同时易于开发，输入js项目，输出可以在浏览器上运行的代码</p><p>工业标准：commomjs</p><h2 id="express-后端"><a href="#express-后端" class="headerlink" title="express 后端"></a>express 后端</h2><p>原始：基于表单、模板渲染驱动</p><p>现在：基于AJAX驱动</p><h3 id="API-HTTP请求"><a href="#API-HTTP请求" class="headerlink" title="API HTTP请求"></a>API HTTP请求</h3><p>请求、响应  状态</p><p>Postman发送网络请求的工具</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求处理函数</p><p>ruquest对象 response请求</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>前端开发框架</p><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>What is Vue.js?</p><p>渐进式的前端开发框架 MVVM</p><p>两个大括号包起来的是插值 只在data以及另外一个 属性中成立</p><script src="https://unpkg.com/vue/dist/vue.js"></script><p>谓词 v-if（条件） v-on （监听点击） v-for (循环) v-bind（双向绑定）</p><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p>context 对象</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>关系型数据库 MySQL 数据需要有一定的规范</p><p>MongoDB</p><h2 id="Hasura"><a href="#Hasura" class="headerlink" title="Hasura"></a>Hasura</h2>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP期末复习</title>
      <link href="2021/06/11/OOP%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>2021/06/11/OOP%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><p>参考<a href="http://www.cplusplus.com/">www.cplusplus.com</a></p><p>大纲：</p><ol><li>类、对象</li><li>组合、继承</li><li>虚函数、多态</li><li>模范、泛型编程</li><li>设计模式</li></ol><p>命令行</p><p>编译器指令</p><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><p>只编译 1. g++ -c main.cpp -o main.o  g++ -c one.cpp -o one.o</p><p>链接 g++ main.o one.o -o main.cpp</p><p>头文件只编译一次： #pragma once </p><p>函数声明：</p><pre><code class="c++">int add(int a,int b);extern int a;extern int arr[100];</code></pre><p>宏定义及使用 宏替换时一一替换</p><p>宏定义可以用于Debug的输出</p><h3 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h3><p>其中可以定义变量，可以使用BASH语法</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通过 argc argv 传入</p><p>argc是参数的个数，包含程序名称</p><p>argv是参数数组，0号位是程序名称</p><h3 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h3><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>返回类型、名称相同，参数类型不同</p><p>在没有对应参数类型的调用时，会自动转换类型</p><p>缺省值（默认值），缺省值必须时最后的参数</p><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>自动确定类型，需要在编译器就能够确定类型。</p><p>用于取代冗长的变量类型。</p><p>声明依赖模板参数的变量类型。</p><p>c++14 中，auto可以直接自动推导返回值类型</p><h3 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a>decltype 关键字</h3><p>对变量、表达式的类型进行推导，也可以重用没有名字的变量类型。</p><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><pre><code class="c++">delete ptr;//删除指针指向的单个内存delete[] array;//删除多个单元组成的内存块</code></pre><p>使用零指针时，注意会不会是0，可能被当成0（在函数重载时），使用nullptr作为真正的零指针</p><h3 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h3><pre><code class="c++">//基于范围的循环for(auto e:array);cout&lt;&lt;e;</code></pre><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>权限分组：private protected public</p><p>调用：</p><ol><li>对象名.成员名</li><li>对象指针-&gt;成员名</li></ol><p>所有成员函数的参数当中有一个指向当前对象的指针this</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><pre><code class="c++">inline int max(int a,int b)&#123;    return a&gt;b?a:b;&#125;</code></pre><p>内联关键词为 inline</p><p>与宏定义相比，编译器自己操作的内联函数不会有代换时的歧义，并且可以正常进行调试</p><p>注意：</p><ol><li>避免堆复杂结构使用内联，否则每个地方复制一份会比较臃肿</li><li>内联函数的实现要和声明放在一起，才能够正确内联</li><li>内敛修饰符是建议，不是命令，编译器会自己判断</li></ol><h3 id="构造、析构"><a href="#构造、析构" class="headerlink" title="构造、析构"></a>构造、析构</h3><p>构造函数：</p><ul><li>可以重载</li><li>可以使用初始化列表，数据成员（初始值），按照不同数据成员的声明顺序来初始化</li><li>初始化列表当中也可以调用其他<strong>构造函数</strong></li><li>C++11后成员变量可以就地初始化</li><li>存在其他构造函数时，不会合成默认构造函数，可以使用下述代码复用</li></ul><pre><code class="c++">A()=default;A(int a)=delete;//禁止某个构造函数</code></pre><p>析构：</p><ul><li>编译器自动调用</li><li>编译器会自动合成默认析构函数</li></ul><p>全局对象：</p><ol><li>构造：发生在main()之前，同一文件中按定义顺序初始化，不同文件中不确定</li><li>main()return之后被析构</li><li>尽量少用全局对象</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用必须在定义时初始化，不能更改指向</p><p>返回值可以是引用，但不能指向临时变量</p><p><strong>引用存在的主要意义是为运算符重载提供便利</strong></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>函数名称为operetor+或者其他运算符即可，参数可以确定或者更改，不再赘述</p><p>大部分运算符都可以重载，自创的诡异运算符不行（毕竟运算符重载是为了实现多态）</p><p>注：</p><ol><li>前缀++不需要参数，后缀++需要一个哑元dummy，在使用时，前缀表示，先++在运算，后缀表示先运算再++</li><li>小括号重载注意参数要再写一个小括号</li><li>= [] () -&gt; 四个运算符只能通过成员函数来重载</li><li>流重载，在修改流的情况下，只能够使用全局函数重载</li></ol><pre><code class="c++">ostream&amp; operator&lt;&lt;(ostream&amp; out,const A&amp; a)&#123;    out&lt;&lt;a.data;    return out;&#125;</code></pre><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元的声明只能在类内，使用friend关键字，友元可以是类、函数，友元可以访问类内的一切成员</p><p>注：友元不能继承，声明友元类时，该类应该已经被声明</p><h3 id="静态、常"><a href="#静态、常" class="headerlink" title="静态、常"></a>静态、常</h3><p>静态：static修饰，只能够用于其声明的文件内部</p><p>静态数据成员：</p><ul><li>由所有成员共享，可以通过类名，也可以通过对象来访问</li><li>需要在实现文件当中赋值</li></ul><p>静态成员函数：</p><ul><li>对函数进行static关键字修饰</li><li>只能访问静态成员变量</li></ul><p>常量：const关键字修饰</p><p>常量数据成员：</p><ul><li>每个对象各有一份</li><li>初始化方式限制：<ul><li>初始化列表</li><li>就地初始化</li><li><strong>禁止</strong>在构造函数体内初始化</li></ul></li></ul><p>常量成员函数：</p><ul><li>使用const修饰</li><li>只能够进行一些外部操作，不能对对象内部数据进行修改</li></ul><p>常量对象：不能更改自身，只能够通过常量成员函数进行一些对外的操作</p><p>常量静态变量：</p><ul><li>需要在类外进行定义：<ul><li>int和enum类型可以就地初始化</li></ul></li></ul><p>静态全局对象：限制全局对象的作用域只在本文件中（全局对象作用域是整个程序）</p><p>静态局部对象：起到全局对象的作用，将局部对象的生命周期延长到整个程序</p><h3 id="指针析构问题"><a href="#指针析构问题" class="headerlink" title="指针析构问题"></a>指针析构问题</h3><p>对象中含有指针成员时，可能会RE</p><p>主要问题在于，调用以对象作为参数的函数时，会复制一份该指针，函数结束后，复制的对象删除，指针也随之删除，原对象再次删除时会RE</p><p>解决办法：将上述函数参数改为对象指针或引用</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>使用情况：</p><ol><li>以一个对象定义另外一个对象</li><li>函数调用时以类的对象为形参</li><li>函数返回类对象</li></ol><p>结果：得到一个新对象，与原来相同</p><p>定义方式：按构造函数定义，函数参数改为类的常量对象，拷贝构造函数效率与构造函数差不多。</p><p>该构造函数内不需要语句进行赋值，赋值工作会自动完成。</p><p>拷贝赋值运算，即正常的等号赋值，类似于拷贝构造，只是在已有对象内操作。</p><p>拷贝构造函数和拷贝赋值运算在缺失时会被编译器自动合成。</p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h4 id="移动和右值"><a href="#移动和右值" class="headerlink" title="移动和右值"></a>移动和右值</h4><p>右值引用：引用常量、表达式、函数返回值</p><p>注：右值引用本身是左值即</p><pre><code class="c++">int &amp;&amp;e=1+2;int &amp;a=e;cout&lt;&lt;a;//输出3</code></pre><p>右值引用可以实现内存名的改变，称为移动</p><p>即，原来地址a存放变量x，值为1，用move配合右值引用后，x可以改名为y，x本身失去意义。</p><p>移动发生后，被移动的量失效。</p><h4 id="移动构造函数-1"><a href="#移动构造函数-1" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>将构造函数的参数改为右值引用的对象即可，亦不需要手动添加赋值语句。</p><p>在调用时，需要右值的参数，可以使用move语句将左值转换为右值，或者原本就是右值。</p><p>移动赋值运算，对等号实现移动构造的效果。</p><p>移动的操作（包括移动构造和移动赋值）需要手动定义。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>定义运算符：</p><ol><li>在被转换类中定义运算符，不需要指定类型</li><li>在目标类中，定义以被转换类作为参数的构造函数</li></ol><p>自动转换的分类：</p><ol><li>显示转换，即直接调用上述转换函数</li><li>隐式转换，即在其他函数调用时，参数类型不对，例如把int塞给了以float类型为参数的函数</li></ol><p>在转换函数前添加explicit关键字可以禁止隐式转换</p><pre><code class="c++">explicit operator Dst()&#123;    ;&#125;explicit Dst(const Src &amp;s)&#123;    ;&#125;</code></pre><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>const_cast</p><p>static_cast</p><p>dynamic_cast</p><p>reinterpret_cast</p><p>具体如何使用，未讲解 </p><h3 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h3><p>组合：将其他类作为数据成员，在初始化其他类时，需要在初始化列表中进行</p><p>继承：从一个类派生出新的类，继承也有权限关系，继承成员数据和大部分成员函数，构造、析构、赋值运算符以及友元不继承</p><p>派生类的构造：</p><ul><li>继承来的数据需要调用基类的构造函数，可以让编译器自动调用，也可以手动调用（必须在初始化列表中调用）</li><li>可以使用using Base::Base 来复用基类的构造函数，在使用时视为派生类的构造函数，这种用法会把所有基类的构造函数重载全部复用</li></ul><p>继承时的权限取交集，越来越小</p><h3 id="重写隐藏"><a href="#重写隐藏" class="headerlink" title="重写隐藏"></a>重写隐藏</h3><p>在派生类当中定义重名函数，屏蔽掉基类当中所有的同名（不论参数类型）函数，使用using关键字可以恢复使用</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>可能会有部分变量重名，在调用时，在变量名前添加来源类名进行限制</p><h3 id="向上类型转换"><a href="#向上类型转换" class="headerlink" title="向上类型转换"></a>向上类型转换</h3><p>将派生类的对象、引用、指针转换为基类的对象、引用指针，为了封装的完整性，只对public继承有效</p><ol><li>对象的向上类型转换：发生切片，丢失数据和方法</li><li>指针和引用的转换，不会丢失原来对象的数据，但是只能够访问基类部分的数据和服务</li><li>若要使得基类指针能够访问派生类数据、功能，需要在基类当中将该函数实现为虚函数，使用virtual关键字（实际实现是构建出一个虚函数表，每一个类有一个表，每一个对象有一个指向它的指针）</li><li>构造函数不能也不必是虚函数</li><li>析构函数最好实现为虚函数，可以精准删除对象的指针</li><li>虚函数只需要在基类中添加关键字即可</li><li>override关键字：命令编译器检查基类中是否有对应虚函数的存在，使得能够重写成功</li><li>final关键字：禁止后续的重写；禁止后续类的继承（即不允许继承当前类）</li></ol><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><pre><code class="c++">virtual int func(int a)=0;</code></pre><ul><li>包含纯虚函数的类（称为抽象类）不能够定义对象，存在的作用是作为基类统一接口，作为多态的操作窗</li><li>抽象类派生类必须重写所有虚函数</li><li>纯虚函数能够防止对象的向上类型转换，只允许指针和引用的这种操作</li></ul><p>向上类型转换可以直接使用基类的指针或引用进行new操作</p><h3 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h3><p>将基类指针转化为派生类，进而使用派生类的特性：</p><ol><li><p>dynamic_cast</p><pre><code class="c++">T2* p=dynamic_cast&lt;T2*&gt;(base);T2&amp; r=dynamic_cast&lt;T2&amp;&gt;(baser);</code></pre><p> 在失败时，指针会返回空指针，而引用会抛出bad_cast异常</p><p> 耗时比较久</p></li><li><p>static_cast</p><p>用法与dynamic_cast相同，关键字更改即可。在转换时不会检查类型，直接转换，可能出现问题，但节约时间开销</p></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>通过向上/下类型转换、虚函数、指针、模板可以实现多态，提高可复用性</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>注：模板必须在头文件中实现，不能够声明和实现分开</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>在函数前添加模板关键字</p><pre><code class="c++">template&lt;class T&gt;T sum(T a, T b)&#123;    return a+b;&#125;</code></pre><p>函数模板在调用时，编译器可以自动推导出实际类型，而不需要添加关键字</p><p>注：模板的错误会有巨量报错，只看最上方几行</p><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板中除了类型参数外，还可以有其他非类型参数</p><pre><code class="c++">template &lt;class T,unsigned size&gt;class array&#123;    T ele[size];&#125;;</code></pre><p>非类型参数可以是整数、枚举、指针、引用、无符号整数(unsigned)</p><p>在使用模板构造类时，不能够使用变量作为非类型参数的实参</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>定义命名空间：</p><pre><code class="c++">namespace A&#123;    int x,y;&#125;</code></pre><p>使用using关键字进行使用</p><h3 id="STL初步"><a href="#STL初步" class="headerlink" title="STL初步"></a>STL初步</h3><p>分为两类：container algorithm</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ol><li><p>pair:</p><ol><li>通过first、second两个成员变量获得数据</li><li>创建：make_pair(a,b)</li><li>支持比较，先比较第一个，再比较第二个</li><li>在map中常用</li></ol></li><li><p>tuple：</p></li><li><p>vector:</p><ol><li><p>允许下标访问</p></li><li><p>末尾添加/删除：</p><ol><li>x.push_back()</li><li>x.pop_back()</li></ol></li><li><p>有迭代器</p></li><li><p>for遍历</p><p>for(auto x:vec)</p></li><li><p>当下迭代器失效</p></li></ol></li><li><p>list</p><ol><li>不支持下标</li><li>基本操作与vector类似</li></ol></li><li><p>set</p></li><li><p>map</p></li></ol><p>选择合适的容器</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>STL提供了方便的string类型</p><p>string可以通过加法实现拼接，也能够使用COUT输出</p><pre><code class="c++">string s0(s1,3,4);//从s1角标3开始，长度为4string s2(10.&#39;aa&#39;);//复制字符aa一共10次str.size();//查询长度str.length();//查询长度str.clear();//清空str.empty();//检查是否为空str.push_back(&#39;a&#39;);//末尾加入str.append(s0);//扩展getline(cin,s0,&#39;s&#39;);//读入存放在s0，以s作为分隔符//加法实现拼接//字典序比较大小int a=stoi(a);//可以转换类型string a =to_string(1);</code></pre><h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>控制格式</p><pre><code class="c++">cout &lt;&lt; fixed &lt;&lt; 2018.0 &lt;&lt; &quot; &quot; &lt;&lt; 0.0001 &lt;&lt; endl;                //浮点数 -&gt; 2018.000000 0.000100cout &lt;&lt; scientific &lt;&lt; 2018.0 &lt;&lt; &quot; &quot; &lt;&lt; 0.0001 &lt;&lt; endl;                //科学计数法 -&gt; 2.018000e+03 1.000000e-04cout &lt;&lt; defaultfloat;  //还原默认输出格式cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl;                //输出精度设置为2 -&gt; 3.2cout &lt;&lt; oct &lt;&lt; 12 &lt;&lt; &quot; &quot; &lt;&lt; hex &lt;&lt; 12 &lt;&lt; endl;                 //八进制输出 -&gt; 14  十六进制输出 -&gt; ccout &lt;&lt; dec;    //还原十进制cout &lt;&lt; setw(3) &lt;&lt; setfill(&#39;*&#39;) &lt;&lt; 5 &lt;&lt; endl;                //设置对齐长度为3，对齐字符为* -&gt; **5</code></pre><p>每次更改后记得还原</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>&lt;regex&gt;库</p><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数指针：</p><pre><code class="c++">void (*func)(int&amp;);//指针的声明//包括返回值，*，变量名，参数列表//可以使用auto确定auto func=a&gt;b?func1:func2;</code></pre><p>使用：</p><ol><li>std::sort自定义</li></ol><pre><code class="c++">bool compare(int a,int b)&#123;    return a&gt;b;&#125;int main()&#123;    int array[100];    int i=0;    while(i&lt;100)&#123;        cin&gt;&gt;array[i];        i++;    &#125;    sort(array,array+100,compare);    return 0;&#125;</code></pre><p>STL中的函数对象：</p><ol><li>greater&lt;int&gt;() 返回a&gt;b</li><li>less&lt;int&gt;() 返回a&lt;b</li></ol><p><strong>如何定义函数对象</strong></p><ol><li>需要重载（）运算符</li><li>括号访问权限为public</li></ol><p>使用时只需要像函数一样使用就可以，记得带小括号</p><pre><code class="c++">class Comp&#123;public:    bool operator()(int a,int b)const&#123;        return a&gt;b;    &#125;&#125;;Comp()(1,2);//输出0</code></pre><h4 id="function类"><a href="#function类" class="headerlink" title="function类"></a>function类</h4><p>来自于&lt;functional&gt;头文件，为函数指针和对象提供了统一的接口</p><p>可以兼容普通函数以及函数对象</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>来自于&lt;memory&gt;头文件</p><pre><code class="c++">shared_ptr&lt;int&gt; p1(new int(1));//从一个普通的裸指针进行构造//各种操作（取*取成员函数）如同普通指针p1.get();//获取裸指针p1.reset();//清除指针并且减少引用计数</code></pre><p>两个智能指针互相引用时，可能不会自动销毁，造成内存泄漏。</p><p>可以使用弱引用来改善</p><pre><code class="c++">weak_ptr&lt;int&gt; i;//弱引用指向对象但不计数//弱引用指针需要从智能指针获得weak_ptr&lt;int&gt; wp1=p1;wp.use_count();//获取引用计数wp.reset();//清除指针wp.expired();//检查对象是否无效sp=wp.lock();//弱转智能</code></pre><p>unique_ptr：保证一个对象只被一个指针指向</p><pre><code class="c++">auto up1=make_unique&lt;int&gt;(2);//构造unique_ptr&lt;int&gt; up2=move(up1);//移动，不能复制int *p=up2.release();//释放，获得裸指针</code></pre><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>行为型模式有三种：</p><ol><li>模板方法模式</li><li>策略模式</li><li>迭代器模式</li></ol><h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义算法的骨架，可变部分调用其他函数来完成</p><p>骨架在基类当中完成，其他函数通过派生出相应的派生类来完成，使用向下类型的指针实现多态。</p><p>将可变部分定义为虚函数即可</p><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>定义一系列算法类并加以封装，作为算法骨架类构造函数的参数来完成组合拼装</p><p>细节操作上，每一种算法有一个抽象接口类，不同实现有不同的派生类，使用时，将派生类向下转换为基类的指针，用来构造出整个算法</p><p>可以降低代码冗余，但是封装性比较差</p><p><strong>模板方法和策略模式都是实现某一算法多态时的设计模式，具体实现依赖于算法步骤的切割</strong></p><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>将一组数据聚合为一个整体，提供一个统一的接口</p><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p>结构型设计模式三类：</p><ol><li>适配器</li><li>委托/代理模式</li><li>装饰器模式</li></ol><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>进行接口的转换，对不同的类实现兼容</p><p>实现手法：private继承或是组合</p><h5 id="代理委托"><a href="#代理委托" class="headerlink" title="代理委托"></a>代理委托</h5><p>在被访问对象上添加一个访问层，类似于中介，同时可以进行新的控制操作</p><p>通常的实现操作，代理类继承原有类，且包含一个原有类的子对象</p><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>在原类之外构建一个装饰品大类，之后构造每个细节的装饰品类（继承自装饰品类），在每个类当中都能包含一个指向实际内容的指针即可。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
            <tag> notes </tag>
            
            <tag> review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理与诗书曲画</title>
      <link href="2021/06/06/%E7%89%A9%E7%90%86%E4%B8%8E%E8%AF%97%E4%B9%A6%E6%9B%B2%E8%AF%9D/"/>
      <url>2021/06/06/%E7%89%A9%E7%90%86%E4%B8%8E%E8%AF%97%E4%B9%A6%E6%9B%B2%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="物理与诗书曲画"><a href="#物理与诗书曲画" class="headerlink" title="物理与诗书曲画"></a>物理与诗书曲画</h2><h3 id="乐器发声中的物理知识——以驻波为例"><a href="#乐器发声中的物理知识——以驻波为例" class="headerlink" title="乐器发声中的物理知识——以驻波为例"></a>乐器发声中的物理知识——以驻波为例</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理:"></a><strong>基本原理</strong>:</h4><p>大部分乐器的发生原理都是振动和波动，通过弦、鼓皮或者是空气柱的振动来激发出声波，进而产生乐音。在演奏音乐时，最为重要的是控制每一个音符的音调，从而形成一曲抑扬顿挫、荡气回肠的优美音乐。</p><p>乐器对音调的控制是通过控制乐器中振动部分振动时的频率来实现的。在管乐器当中，控制的是空气柱振动的频率，在打击乐器当中，控制的是鼓皮振动的频率，而在弦乐器当中，控制的是弦振动的频率。</p><p>不同乐器控制频率的做法是改变振动部分的固有频率。在外力作用下，振动部分会以固有频率进行振动，通过控制固有频率就可以实现对声音音调的控制。</p><h4 id="控制方法中的物理"><a href="#控制方法中的物理" class="headerlink" title="控制方法中的物理"></a><strong>控制方法中的物理</strong></h4><p>乐器当中振动部分的固有频率是它所能够形成的驻波的频率。这个频率由波传播的速度和波的波长来决定，因为波传播的速度可以视为一个常量，因此主要通过控制形成驻波的波长来控制频率。</p><h4 id="如何控制波长？"><a href="#如何控制波长？" class="headerlink" title="如何控制波长？"></a><strong>如何控制波长？</strong></h4><p>驻波在形成的时候，要受到外部环境机械尺寸的限制。例如，封闭管腔的末端，形成的一定是波节，即振幅恒定为零的点，在管口与空气接触的地方，形成的一定是波腹，即振幅最大的点。通过控制波腹与波节的距离，就可以实现对波长的控制。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用:"></a><strong>应用</strong>:</h4><p>在管乐器当中，通过控制管长可以改变驻波的波长，进而改变音调，如口风琴，也可以通过控制末端的封闭与否来改变发出声音的音调（如下图）。</p><p><img src="https://i.loli.net/2021/06/06/VZbnF5lm21WK7G4.png" alt="笛中的驻波.png"></p><p>在打击乐器当中，控制鼓皮的松紧，可以改变驻波形成区域的机械尺寸，进而控制驻波的波长，产生不同的简正模式，即形成不同的音调。如下图当中，有六种不同的简正模式，就可以发出六种不同的音调。</p><p><img src="https://i.loli.net/2021/06/06/2O9RtliJ3hPUHIk.png" alt="鼓皮上的驻波.png"></p><p>弦乐器的发声也是通过驻波来实现的。控制拉弓的速度可以调整驻波的振幅，进而来控制发出声音的音量；通过左手按压琴弦，就可以在弦上人为制造出一个振幅为零的波节，从而限制琴弦上驻波的波长，达到控制音调的目的。</p><p><img src="https://i.loli.net/2021/06/06/vs7UXy5V9EJpnKC.png" alt="弦乐器.png"></p><h3 id="不同乐器差别中的物理知识"><a href="#不同乐器差别中的物理知识" class="headerlink" title="不同乐器差别中的物理知识"></a>不同乐器差别中的物理知识</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>不同乐器以相同的音调发出的声音也是不同的，这种差异主要是由不同乐器波形的不同引起的。乐音在我们听来之所以好听，是因为乐音具有较为短小的周期，利用这种周期性，就可以对乐音的波形进行研究。</p><p>研究周期性的一个好工具就是傅里叶分析，通过对不同乐器在相同频率下形成的音波进行傅里叶频谱分析，可以发现：不同乐器的基频，也就是最低的频率，是相同的，这个频率决定了音调；但不同乐器的高次谐频，也就是频率更高的一部分，是不相同的，这部分驻波的频率决定了音色，也因此，不同的乐器在相同的音调下发出的声音不同。</p><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>通过对高次频谱的分析，可以看到每一种乐器的发音特点（如下图），并进行比较，进而可以选出比较适合的乐器搭配。</p><p><img src="https://i.loli.net/2021/06/06/atxZiGsJVSQIfvP.png" alt="音质与波形的关系.png"></p><p><img src="https://i.loli.net/2021/06/06/SKqZNalx5LncuIQ.png" alt="音质与波形的关系2.png"></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP笔记（3）</title>
      <link href="2021/05/24/oop_note3/"/>
      <url>2021/05/24/oop_note3/</url>
      
        <content type="html"><![CDATA[<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>给函数赋值</p><pre><code class="c++">void increase(int &amp;x)&#123;x++;&#125;void (*func)(int&amp;);//声明指针func=increase;int x=1;func(x);//可以使用auto推断函数名类型auto func = increase;//需要函数指针指向一个已有的函数</code></pre><p>函数也可以作为变量</p><pre><code class="c++">bool compare(int a,int b)&#123;    return a&gt;b;&#125;std::sort(a,a+6,compare);//compare是一个函数指针//以函数对象作为函数指针，要带上（），并且要求是public权限//sort函数的第三个参数类型template&lt;class Iterator, class Compare&gt;void sort(Iterator first, Iterator last, Compare come)&#123;    ...;//其中调用come时像函数一样使用即可&#125;</code></pre><p>自定义类型的排序：</p><ol><li>重载小于运算符</li><li>自定义比较函数</li><li>自定义比较函数对象</li></ol><p>程序设计时，有可能整个算法的每个步骤都有多种选择</p><p>设计方法：</p><ol><li>基于虚函数的模板设计模式，用含虚函数的类作为基类，再继承出派生类</li><li>使用函数指针作为参数来设计函数，或者使用函数对象作为模板内的类型，模板既可以接受函数指针，也可以接受函数对象。</li></ol><p>函数指针和函数对象的统一：</p><pre><code class="c++">#include &lt;functional&gt;function&lt;void(int,double)&gt; add[]=&#123;func1,func2()&#125;;//func1是指针,func2()是函数对象//function是一个模板类</code></pre><p>function也可以单个被赋值，仅仅根据函数返回值类型和参数类型来确定function的类型</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>指针的销毁问题（多个指针指向一个对象，应该在所有指针都销毁后再销毁对象）</p><p>shared_ptr 来自于<memory>库</p><pre><code class="c++">#include &lt;memory&gt;//构造shared_ptr&lt;int&gt;p1(new int(1));shared_ptr&lt;Class1&gt; p2=make_shared&lt;Class1&gt;(233);shared_ptr&lt;Class1&gt; p3=p2;shared_ptr&lt;int&gt; p4;//空指针//访问int x=*p1;int y=p2-&gt;data;//访问对象的某个变量</code></pre><p>实现思路：</p><p>采用一个辅助指针指向真正的对象，然后对外部指针进行计数，计数为0则删除辅助指针和对象。</p><p>实际设计时，辅助指针设置为一个类，外部指针为成员变量为辅助指针的类，为了方便访问，外部指针类为辅助指针类的友元。</p><p>设计时，要考虑一个外部指针通过赋值改变类型的行为。</p><p>shared_ptr的其他用法</p><pre><code class="c++">p.get();//获取裸指针p.reset();//清除指针并且减少引用次数</code></pre><p>不能使用同一个裸指针初始化多个智能指针，原因：裸指针的构造函数当中，会构造一个辅助制造。为避免此，构造第二个智能指针要求使用第一个指针来赋值。</p><p>不能直接使用智能指针维护对象数组，因为数组的销毁方式有[]。</p><p>弱引用：避免两个对象内的指针相互指向而无法销毁，造成内存泄露。</p><p>弱引用可以指向对象但不计数</p><pre><code class="c++">shared_ptr&lt;int&gt; sp(new int(2));weak_ptr&lt;int&gt; wp1=sp;//若引用指针需要用智能指针来赋值//其他用法wp.use_count();//获取引用计数wp.reset();//清除指针wp.expired();//检查对象是否无效sp=wp.lock()//从弱引用获得一个智能指针</code></pre><p>独享所有权的指针：保证一个对象只能被一个指针引用，使用unique_ptr</p><pre><code class="c++">#include &lt;memory&gt;#incldue &lt;utility&gt;using namespace std;int main()&#123;    auto up1=std::make_unique&lt;int&gt;(12);    unique_ptr&lt;int&gt; up2=up1;//错误，不能复制    unique_ptr&lt;int&gt; up2=std::move(up1);//可以移动    int *p=up2.release();//放弃控制权，返回一个指针    delete p;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫</title>
      <link href="2021/05/21/note_of_python_3/"/>
      <url>2021/05/21/note_of_python_3/</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ol><li><p>引入专用库</p><pre><code class="python">from urllib.request import urlopenfrom bs4 import BeautifulSoup</code></pre></li><li><p>调用urlopen获得一个网页</p><pre><code class="python">html1=urlopen(&quot;https://morvanzhou.github.io/static/scraping/basic-structure.html&quot;).read().decode(&#39;utf-8&#39;)#中文要求转换</code></pre></li><li><p>使用BeautifulSoup解析</p><pre><code class="python">soup=BeautifulSoup(html1,features=&#39;lxml&#39;)#其他指令soup.h1#h1标题href=soup.find_all(&#39;a&#39;)#找到所有的a标签,生成一个dict的listprint(herf[1][&#39;herf&#39;])#直接通过下标访问</code></pre></li><li><p>爬取css代码，其中的类可能放在head中，通过类名定位想要的内容</p><pre><code class="python">jan=soup.find(&#39;ul&#39;,&#123;&quot;class&quot;:&#39;jan&#39;&#125;)#查找所有ul标签下类为jan的东西，并生成list#找到&lt;ul class=&quot;jan&quot;&gt;#&lt;li&gt;一月一号&lt;/li&gt;#&lt;li&gt;一月二号&lt;/li&gt;#&lt;li&gt;一月三号&lt;/li&gt;#&lt;/ul&gt;</code></pre><p>即每次可以根据标签生成一个list，然后可以用类来特化标签再生成，之后可以用.get_text()得到标签所含的文本，其中的类名可以用正则表达式来匹配</p><pre><code class="python">img=soup.find_all(&quot;img&quot;,&#123;&quot;src&quot;:re.compile(&#39;表达式&#39;)&#125;)</code></pre></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python笔记（2）</title>
      <link href="2021/05/20/note_of_python_2/"/>
      <url>2021/05/20/note_of_python_2/</url>
      
        <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>写文件</p><pre><code class="python">#open读写，注意换行和Tab的转译string=&#39;tests12\n1221\tawdaw&#39;my_file=open(&quot;test.txt&quot;,&quot;w&quot;)my_file.write(string)my_file.close()</code></pre><p>w操作可以重写文件，r操作只读文件，a(append)操作可以续写文件</p><pre><code class="python">string=&#39;\ntestagain&#39;my_file=open(&quot;test.txt&quot;,&quot;a&quot;)my_file.write(string)my_file.close()</code></pre><p>读文件</p><pre><code class="python">read=open(&#39;test.txt&#39;,&#39;r&#39;)content=read.read()#读全部content2=read.readline()#读一行，但是上面读过全部，这里什么也读不到print(content,content2)#每个文件的每行在每次打开时只能读取一次，后面需要重新打开content3=read.readlines()#读取所有行，可以按行迭代for i in content3:    print(i)</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的定义与C++类似</p><pre><code class="python">#类的定义class Dog:    data=1    def add1(self):#self指*this，在函数体内调用参数是要带上self.        self.data+=1        print(self.data)    def __init__(self,data):#构造函数        self.data=data        print(data)pup=Dog()#这个括号必须要有，用来实例化一个类的对象pup.add1()#记得带括号</code></pre><p>对对象的操作</p><pre><code class="python">import copy#id(a)#取a的地址a=[2,3,[5,6]]b=a#引用aprint(id(a),id(b))c=copy.copy(a)#拷贝a中各项的引用print(id(a),id(c))print(id(a[1]),id(c[1]))d=copy.deepcopy(a)#拷贝一个一模一样的a，在a改变时重新开辟内存print(id(a),id(d))print(id(a[1]),id(d[1]))</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code class="python">#python使用的输入为input()，中间可以加参数来输出提示input1=input(&#39;please?:&#39;)print(input1)#在某些使用时，要强制类型转换</code></pre><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="tuple和list"><a href="#tuple和list" class="headerlink" title="tuple和list"></a>tuple和list</h4><p>两种容器内的元素可以是任意类型</p><pre><code class="python">#tuple的定义可以带小括号也可以不带tupleone=(13,2,5,7,8)tupletwo=1,3,4,6,7#list的定义必须带中括号listone=[12,3,45,7,7]#两种容器都可以像数组一样直接通过下标访问，下标从0开始print(tupleone[3])print(listone[3])#两种容器的元素都可以被迭代输出for i in tupleone:    print(i)for i in listone:    print(i)</code></pre><p>list的其他功能</p><pre><code class="python">list_one=[1,4,46,7]list_one.append(&#39;adwad&#39;)#在末尾增加一个元素print(list_one)#输出整个listlist_one.insert(3,&#39;test&#39;)#在3位置插入testlist_one.remove(4)#删去值为4的元素print(list_one)#输出整个list#排序不支持字符串和int混排，但支持字符串排序list_one.sort()#从小到大排序print(list_one)#输出整个listlist_one.sort(reverse=True)#从大到小排序,需要有reverse=print(list_one)#输出整个list#多维listlist_two=[[1,2,3],[3,4,5]]for i in list_two:    print(i)#输出两个有三个元素的一维list</code></pre><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><p>dict</p><pre><code class="python">#dict的定义d1=&#123;&#39;key1&#39;:1,1:&#39;key&#39;,&#39;key2&#39;:3&#125;#按格式即可#可以通过key来调用具体的值print(d1[&#39;key2&#39;])print(len(d1))#查看元素个数#删除操作del d1[&#39;key2&#39;]#这里是中括号print(d1)#添加操作d1[&#39;ad&#39;]=5print(d1)#字典中的元素可以是list,dict,funcdef func():    return 0d4 = &#123;&#39;apple&#39;:[1,2,3], &#39;pear&#39;:&#123;1:3, 3:&#39;a&#39;&#125;, &#39;orange&#39;:func&#125;print(d4[&#39;apple&#39;])</code></pre><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>zip函数接受零个或一个或多个list，并将其合并成一个list，每个位置是原来几个元素的tuple</p><pre><code class="python">a=[9,8,7,6]b=[&#39;awd&#39;,3,5]zip1=zip(a,b)print(list(zip1))#需要添加list来使之可视化#该例输出[(9, &#39;awd&#39;), (8, 3), (7, 5)]</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="python">#字符串和list可以强制转换成setchar_list=[&#39;2&#39;,&#39;t&#39;,&#39;7&#39;,&#39;7&#39;]sentence=&quot;ad dxg xg&quot;a=set(char_list)b=set(sentence)#有空格字符#添加元素，不能是lista.add(&#39;s&#39;)#删除a.remove(&#39;s&#39;)#删除一个a.clear()#清空set#差集并集c=a.difference(b)#差集a-bd=a.intersection(b)#交集</code></pre><h3 id="import模块"><a href="#import模块" class="headerlink" title="import模块"></a>import模块</h3><p>有不同的import方式</p><ol><li><p>在最前面直接import</p><pre><code class="python">import timeprint(time.localtime())#需要有time.前缀</code></pre></li><li><p>import 并且更改参数名</p><pre><code class="python">import time as tprint(t.localtime())#需要有t.前缀</code></pre></li><li><p>只引入部分函数</p><pre><code class="python">from time import time,localtimeprint(time())#不需要前缀</code></pre></li><li><p>引入全部函数</p><pre><code class="python">from time import*#不需要前缀</code></pre></li><li><p>引入本地文件</p><pre><code class="python">#先将本地代码保存在py文件内，然后import#以引入example.py为例import example#本地模块可以放到包库内</code></pre></li></ol><h3 id="try使用"><a href="#try使用" class="headerlink" title="try使用"></a>try使用</h3><pre><code class="python">try:    file=open(&#39;asdsada.txt&#39;,&#39;r&#39;)except Exception as error:    [do]</code></pre><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>用来简化函数定义</p><pre><code class="python">fun= lambda x,y:x+yx=int(input(&#39;x=&#39;))#定义int整数，否则默认输入字符串y=int(input(&#39;y=&#39;))print(fun(x,y))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python笔记（1）</title>
      <link href="2021/05/20/note_of_python_1/"/>
      <url>2021/05/20/note_of_python_1/</url>
      
        <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>python的idle(python专用词，python专用的ide)用的是命令行，也就是源文件中的.exe</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="python">#print用法print(&#39;asda&#39;)#输出asdaprint(&quot;asda&quot;)#输出asdaprint(&quot;asda&quot;+&quot;asd&quot;)#+号可以直接连接字符串&quot;&quot;&quot;输出asdaasd,其中双引号单引号通用，可以混用&quot;&quot;&quot;print(1+1)#输出2，可以直接进行四则运算，除法带有小数print(&quot;fh&quot;,2)#输出fh 2#强制类型转换int(&#39;2.5&#39;)#输出2，双引号、单引号或不加均可以float(&quot;1.2&quot;)#输出1.2&quot;&quot;&quot;python可以直接当成计算器使用，但是字符串不能和数字直接相加&quot;&quot;&quot;</code></pre><h4 id="算符"><a href="#算符" class="headerlink" title="算符"></a>算符</h4><p>数学运算符</p><pre><code class="python">3**2#幂指数，3的2次方3%2#取余3//2#整除</code></pre><p>比较运算符</p><pre><code class="python">#与C++相同1&gt;21&lt;21==21&lt;=21&gt;=21!=2</code></pre><p>逻辑运算符</p><pre><code class="python">and#逻辑与or#逻辑或not#逻辑非</code></pre><p>赋值运算符</p><pre><code class="python">#与C++类似，相应运算符更换即可=+=-=*=%=//=**=</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code class="python">#变量名用字母下划线和数字，第一次出现必须在等号左边num=1#定义数值变量string=&#39;string&#39;#定义字符串变量，必须带上单引号或双引号print(num)print(string)a1,a2,a3=1,2,3#定义三个变量</code></pre><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><pre><code class="python">#while语句，注意冒号和缩进#缩进可以用空格，也可以用Tab，但不能混用&#39;&#39;&#39;while condition:    do&#39;&#39;&#39;a1=1while a1&lt;5:    a1+=1    print(a1)</code></pre><pre><code class="python">#for语句，注意冒号和缩进&#39;&#39;&#39;for i in queue:    do&#39;&#39;&#39;#i是迭代脚标，queue是迭代序列list=[6,3,3,4,5,6]for i in list:    print(i)</code></pre><p>上面两种循环语句均支持continue 和 break操作</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre><code class="python">#if条件判断if condition:    do#if_else语句if condition:    doelse:    do#多重ifif condition1:    do1elif condition2:    do2else:    do3#python里没有三目的判断运算符#类似于三目运算符的行内表达式a1=a2 if c else a3</code></pre><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><pre><code class="python">def function_name(parameter_a,parameter_b):    do    return a#参数可以是默认参数</code></pre><h3 id="外部模块（头文件）"><a href="#外部模块（头文件）" class="headerlink" title="外部模块（头文件）"></a>外部模块（头文件）</h3><p>外部模块安装方式：</p><ul><li>anaconda平台安装</li><li>直接下载安装包手动安装：<ul><li>在包的官网下载对应python版本的whl包</li><li>然后使用pip（python包管理工具）安装</li></ul></li></ul><h4 id="pip使用"><a href="#pip使用" class="headerlink" title="pip使用"></a>pip使用</h4><pre><code>pip install [name] #直接安装包pip install &#39;Markdown&gt;2.0,&lt;2.0.3 #指定版本安装pip uninstall [name]pip listpip freeze &gt; a.txt #将已经安装的库列表保存到文本文件中pip install -r a.txt #根据依赖文件批量安装库pip install a.whl #离线安装whl后缀的包pip install --upgrade [name] #更新包pip show --files [name] #查看包pip list --outdated #查看可更新的包</code></pre><h5 id="pip源的选择"><a href="#pip源的选择" class="headerlink" title="pip源的选择"></a>pip源的选择</h5><p>很多时候，比如网络不给力，连接超时、防火墙阻挡等等各种原因，可能无法从Python官方的PyPi仓库进行pip安装，这时候可以选择国内的第三方源，推荐使用豆瓣源，速度不错。</p><p>使用方法：</p><pre><code>pip install -i https://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com pillowpip install -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>需要注意的是，除了最后的pillow用所期望的库名替代外，前面的参数都是固定写法，包括参数顺序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《曼昆经济学》宏观分册笔记</title>
      <link href="2021/05/19/note_of_macro_economics/"/>
      <url>2021/05/19/note_of_macro_economics/</url>
      
        <content type="html"><![CDATA[<h2 id="第八篇-宏观经济学的数据"><a href="#第八篇-宏观经济学的数据" class="headerlink" title="第八篇 宏观经济学的数据"></a>第八篇 宏观经济学的数据</h2><h3 id="Chapter-23"><a href="#Chapter-23" class="headerlink" title="Chapter 23"></a>Chapter 23</h3><h4 id="GDP：在某一特定时期一个国家内生产的所有最终物品与服务的市场价值（总支出）"><a href="#GDP：在某一特定时期一个国家内生产的所有最终物品与服务的市场价值（总支出）" class="headerlink" title="GDP：在某一特定时期一个国家内生产的所有最终物品与服务的市场价值（总支出）"></a>GDP：在某一特定时期一个国家内生产的所有最终物品与服务的市场价值（总支出）</h4><p>GDP衡量总收入和总支出</p><p>市场价值：市场量化</p><p>所有：不包括不在市场上的东西，以及非法的地下交易</p><p>最终：纸与贺卡，只计算贺卡</p><p>未被使用的中间物品算临时的最终物品(存货投资)</p><p>物品与服务：服务也算</p><p>生产的：现期生产的物品与服务，不包括对过去生产东西的交易</p><p>一个国家：地理范畴</p><p>某一时期：一般将该时期的总量折合为一年（如一个季度的乘以4，便于比较）</p><p>小结：GDP计算的是增值，计算了所有的最终物品、服务，通过存货量的改变减去了原料</p><h4 id="GDP的组成部分（支出法）"><a href="#GDP的组成部分（支出法）" class="headerlink" title="GDP的组成部分（支出法）"></a>GDP的组成部分（支出法）</h4><p>消费、投资、政府购买、净出口</p><p>消费：家庭除房产外的消费</p><p>投资：资本设备、存货、建筑物</p><p>政府购买：公务员薪水 公务支出 补贴（转移支付）不算</p><p>净出口：出口减去进口</p><p>一般消费最大</p><p>真实GDP（以往年（基年）价格）与名义GDP（现期价格）</p><p>一般比较真实GDP</p><h4 id="GDP平减指数（物价加权平均的比值）"><a href="#GDP平减指数（物价加权平均的比值）" class="headerlink" title="GDP平减指数（物价加权平均的比值）"></a>GDP平减指数（物价加权平均的比值）</h4><p>名义/真实*100</p><p>衡量相对于基年的物价水平</p><p>通胀率：（第二年平减-第一年平减）/第一年平减（物价的平均增长率）</p><h3 id="Chapter-24"><a href="#Chapter-24" class="headerlink" title="Chapter 24"></a>Chapter 24</h3><h4 id="消费物价指数CPI-衡量整体生活费用"><a href="#消费物价指数CPI-衡量整体生活费用" class="headerlink" title="消费物价指数CPI 衡量整体生活费用"></a>消费物价指数CPI 衡量整体生活费用</h4><p>CPI:普通消费者所购买的物品与服务的总费用的衡量指标</p><p>计算步骤：</p><ol><li>固定篮子：根据需求确定各种物品的价格所占权重</li><li>找出价格</li><li>计算费用（固定数量和权重，依据每年的市场价格计算）</li><li>选择基年（分母），计算指数CPI=当年/基年*100</li><li>计算通胀率</li></ol><p>可以根据消费物价指数计算物价水平，衡量通货膨胀校正的大小</p><h4 id="通货膨胀的指数化"><a href="#通货膨胀的指数化" class="headerlink" title="通货膨胀的指数化"></a>通货膨胀的指数化</h4><p>名义利率：货币数量变动的利率</p><p>真实利率：根据通货膨胀校正的利率</p><p>真实利率=名义利率-通货膨胀率</p><p>（注：精确的数据应当是（名-胀）/（1+胀）故，通胀时，真实利率比实际偏高，通缩时，比实际偏低）</p><h2 id="第九篇-长期中的真实经济"><a href="#第九篇-长期中的真实经济" class="headerlink" title="第九篇 长期中的真实经济"></a>第九篇 长期中的真实经济</h2><h3 id="Chapter-25-生产与增长"><a href="#Chapter-25-生产与增长" class="headerlink" title="Chapter 25 生产与增长"></a>Chapter 25 生产与增长</h3><p>一般评价真实GDP</p><p>生产率：说明了经济和生活水平的差异</p><p>生产率的决定因素（生产要素）：物质资本、人力资本、自然资源、技术知识</p><ol><li>人均物质资本：生产工具，设备、建筑物的存量 是一种生产出来的生产要素，作为生产的产出</li><li>人均人力资本：工人通过教育、培训或是经验而获得的知识和技能，也是一种生产出来的生产要素</li><li>人均自然资源：自然界提供的：土地、河流、矿藏</li><li>技术知识：对生产物品与服务的最好方法的了解程度。一种是公共知识，另外一种是私人知识。还有专利。</li></ol><p>自然资源的市场价格可以反映该种资源的稀缺性</p><h4 id="提高生产率和生活水平的政府政策"><a href="#提高生产率和生活水平的政府政策" class="headerlink" title="提高生产率和生活水平的政府政策"></a>提高生产率和生活水平的政府政策</h4><ol><li><p>储蓄和投资：投资是指将目前较为稀缺的资源用于生产资本，为此就要求储蓄（指将部分资源用于生产新的资本而非满足消费需求，这部分资源通常以货币的形式储存，在必要时转化为资本），牺牲现期物品与服务的消费（机会成本） 政府鼓励储蓄和投资可以促进经济的增长</p></li><li><p>收益递减和追赶效应：收益递减指资本增加所带来的生产率的提高在递减；追赶效应指贫穷国家由于资本存量少，资本的收益递减效应较低，资本增加所带来的生产率的提高高于富裕国家。</p></li><li><p>来自国外的投资：(增加国内资本存量并且学习技术)</p><ul><li>形式1：国外直接投资：外国实体拥有并经营</li><li>形式2：外国出资购买当地企业股票</li><li>形式3：国外有价证券投资：借用外国货币，到期偿还货币而不与经营状况绑定</li></ul></li><li><p>教育：对长期经济繁荣和物质资本投资十分重要，也有机会成本，具有正外部性（可以对该个体外部的社会知识库产生正的影响）面临人才外流的问题</p></li><li><p>健康与营养：更健康更强壮的人生产率更高，主要观测指标是身高</p></li><li><p>产权和政治稳定</p></li><li><p>自由贸易</p></li><li><p>研究与开发（支持研究，保护专利）</p></li><li><p>人口增长（会导致资源紧张、稀释资本存量、）促进技术进步</p></li></ol><h3 id="Chapter-26-储蓄、投资和金融体系"><a href="#Chapter-26-储蓄、投资和金融体系" class="headerlink" title="Chapter 26 储蓄、投资和金融体系"></a>Chapter 26 储蓄、投资和金融体系</h3><p>金融体系：由帮助将一个人的储蓄与另一个人的投资相匹配的机构组成，协调储蓄与投资之间的关系。</p><p>金融机构的分类：金融市场 金融中介机构</p><h4 id="金融市场"><a href="#金融市场" class="headerlink" title="金融市场"></a>金融市场</h4><p>想储蓄的人可以借以直接向想借款的人提供资金的机构</p><p>目前经济当中最重要的两种金融市场是债券市场和股票市场</p><ol><li><p>债券市场：借款人发售债券，储蓄人购买债券，在到期日之前可以把债券出售给他人，出售债券的融资方式称为债务融资</p><p>债券的重要特点：期限（存在永久债券）， 信用风险（通常有评级机构进行认定），税收待遇（需要交税，美国）（在一定程度上导致政府发行的债券利率较低）</p></li><li><p>股票市场：股票（stock）代表了企业的所有权，代表了企业利润的索取权。出售股票的筹资方式称为权益融资。</p><p>股票可以在有组织的股票市场上交易。美国经济中最重要的证券交易所是纽约证券交易所和纳斯达克（NASDAQ）(全国证券交易商协会自动报价系统)各种股票指数可以用于监测整体的股票价格水平。股票指数是计算出来的一组股票价格的平均数。</p><p>股票的重要参数：价格“最后”“收盘”“最高”“最低”  红利  价格收益</p></li></ol><h4 id="金融中介机构"><a href="#金融中介机构" class="headerlink" title="金融中介机构"></a>金融中介机构</h4><p>金融机构是储蓄者可以借以间接地向借款者提供资金的金融机构 两种最重要的金融中介机构：银行和共同基金</p><ol><li>银行</li><li>共同基金：向公众出售股份，并用收入购买各种股票、债券，即资产组合的机构 可以多元化投资，经营共同基金的公司向股票持有者收取年费，通常为资产价值的0.2%-0.5%</li></ol><h4 id="国民收入账户中的储蓄与投资"><a href="#国民收入账户中的储蓄与投资" class="headerlink" title="国民收入账户中的储蓄与投资"></a>国民收入账户中的储蓄与投资</h4><p>GDP=C+I+G+NX</p><p>封闭经济体内(NX=0)：</p><p>储蓄和S=GDP-CONSUME-GOVERN=INVESTMENT=投资</p><p>私人储蓄：GDP-CONSUME-TEX</p><p>公共储蓄：TEX-GOVERN</p><p>S==I依赖于金融体系在背后的分配调节</p><p>对个体行为来说，投资一般指从金融体系当中获得货币来购买资本（生产工具等），储蓄指将多余的货币投入金融市场。</p><h4 id="可贷资金市场"><a href="#可贷资金市场" class="headerlink" title="可贷资金市场"></a>可贷资金市场</h4><p>吸收所有储蓄，放出所有投资的资金池，可贷资金市场上存在一种利率，是储蓄的收益，借款的成本，利率是贷款的价格。</p><p>供给：储蓄</p><p>需求：投资</p><p>（资金量-利率关系图）</p><p>利率上升，可贷资金需求减少，供给增加，直至达成一种平衡（看不见的手）（看得见的手调整一些因素来使得曲线移动）</p><p>一般公布的利率是名义利率，可贷资金的供求取决于真实利率</p><p>政策：</p><ol><li><p>储蓄激励</p><ul><li>降低利息税，使得某些储蓄免税，不影响投资的量。增加每种利率下可贷资金供给量，交点右移，利率下降，投资增加</li></ul></li><li><p>投资激励</p><ul><li>投资税额减免，需求增加，供给不变。导致利率上升，投资增加。</li></ul></li><li><p>政府预算赤字和盈余</p><ul><li>政府在债券市场上借款为预算赤字筹资，借款的积累是政府债务。财政赤字会降低国民储蓄，供给下降，利率上升，投资减少。由于政府借款引起的投资减少称为 <em><strong>挤出</strong></em> 在这种情况下，投资总额是减少的，但政府赤字导致的GOVERN的增加会导致GDP的增加，但这一部分带来增长的效果弱于投资。</li><li>减税造成的赤字。税收减少，私人储蓄增加，公共储蓄减少；但私人会增加消费，导致总储蓄减少，供给减少，利率抬高。</li><li>财政盈余导致的变化：供给增加，利率减少，投资增加。</li></ul></li></ol><h3 id="Chapter-27-金融学的基本工具"><a href="#Chapter-27-金融学的基本工具" class="headerlink" title="Chapter 27 金融学的基本工具"></a>Chapter 27 金融学的基本工具</h3><p>金融学：研究人们如何在某一时期内做出关于配置资源和应对风险的决策的学科。</p><h4 id="现值：衡量货币的时间价值"><a href="#现值：衡量货币的时间价值" class="headerlink" title="现值：衡量货币的时间价值"></a>现值：衡量货币的时间价值</h4><p>未来一定货币的现值：在现行利率下产生这一未来货币量所需要的现在的货币量。</p><p>终值：现行利率下，现在一定的货币量将带来的未来的货币量。</p><p>复利：每年利息产生利息</p><p>利率为r，N年后得到X量的现值是 X/(1+r)^N</p><p>由于赚到利息的可能性使得现值降到X以下，所以寻找一定量未来货币现值的过程称为贴现。</p><p>70规则：真实值是ln2/ln(1+x%),泰勒公式展开，约为70规则(当利率较小时比较准确)</p><h4 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h4><p>风险厌恶：不喜欢不确定性</p><p>效用：财富增加带来幸福感的衡量指标。</p><p>一般来说，财富越多，效应的增加越少，称为边际效用递减。</p><p>效应关于财富的曲线大约是对数形式。</p><p>效用递减导致人们失去等量财富所产生的厌恶感大于得到等量财富所获得的幸福感</p><p>风险厌恶带来的三种经济活动：</p><ol><li>保险，并不是消除了风险，而是分摊了风险。保险的出现使得高风险情况下更可能购买保险，同时降低了人们为降低风险而采取合适操作的可能性，而保险公司意识到这件事则导致了保费上升。</li><li>多元化。通过多元化来降低风险。可以用预期收益的标准差来衡量风险。标准差越大，面临的风险相对越小。多元化可以消除企业特有风险，无法消除影响整个经济的市场风险。</li><li>风险与收益的取舍。决定如何配置自己的储蓄时，人们必须决定为了赚取高收益要承担多大的风险。</li></ol><h4 id="资产评估"><a href="#资产评估" class="headerlink" title="资产评估"></a>资产评估</h4><p>供给和需求决定了股票的价格。</p><ul><li>基本面分析：为决定一家公司的价值而对其进行的详细分析。可以依靠基本面分析来挑选股票的组合。三种方法：<ol><li>自己阅读公司年报并研究。</li><li>听从金融行业专业分析师的建议。</li><li>购买共同基金。</li></ol></li><li>有效市场假说：</li></ul><h3 id="Chapter-28-失业"><a href="#Chapter-28-失业" class="headerlink" title="Chapter 28  失业"></a>Chapter 28  失业</h3><p>一国生活水平更明显的决定因素是它正常情况下所存在的失业量。失业问题分为两大类：长期失业问题与短期失业问题。</p><p>自然失业率：经济当中正常情况下存在的失业率。</p><p>周期性失业：失业率围绕自然失业率逐年波动，与经济活动的短期上升与下降密切相关。</p><p>讨论自然失业率：（<em><strong>自然</strong></em> 是指这种失业率在长期中不会消失）</p><h4 id="衡量失业"><a href="#衡量失业" class="headerlink" title="衡量失业"></a>衡量失业</h4><p>相关部门调查失业类型，平均工作周长度，失业的持续时间，来自于对众多家庭的定期调查。</p><p>将成年人分为三类：</p><ol><li>就业者</li><li>失业者（能够工作但没有找到工作的人以及被解雇等待招回的人）</li><li>非劳动力（除前两类之外的人）：全日制学生、家务劳动人员、退休人员、残疾人？</li></ol><p>劳动力=就业者+失业者</p><p>失业率=失业者/劳动力</p><p>劳动力参工率=劳动力/成年人口</p><p>失业率并不准确，存在各种误差</p><p>大多数失业（人次）是短期的，但每个时间切片上，大多数的失业是长期的。</p><p>失业的四种原因：</p><ol><li>摩擦性失业：工人与工作匹配过程所消耗时间造成的失业</li><li>结构性失业：劳动岗位小于劳动力总数（主要是由工资高与供给需求平衡点引起）引起高工资的原因：最低工资法、工会、效率工资</li></ol><h4 id="寻找工作"><a href="#寻找工作" class="headerlink" title="寻找工作"></a>寻找工作</h4><p>工作的信息传播地越快，则摩擦性失业就会越少。</p><p>如果政策可以提高这种信息传播速率，就可以降低自然失业率。主要地政策方法：</p><ol><li>通过政府管理地就业机构发布职位空缺的信息。</li><li>开展公共培训计划，让处于衰落行业的工人转移到增长行业中。</li></ol><p>失业保险：工人失业是为他们提供部分收入保障的政府计划。失业保险在一定程度上增长了自然失业率。失业者会拒绝不那么有吸引力的工作岗位。在一定程度上，失业保险遏制了就业人数的增长。包括：食品补助、残疾补贴、公共助学金、广泛长期的失业补助、边际税率。</p><h4 id="最低工资法"><a href="#最低工资法" class="headerlink" title="最低工资法"></a>最低工资法</h4><p>大部分工人的工资高于最低工资标准，它对这部分人的就业影响不大，而对不熟练工人和青少年的影响较大。</p><p>当工资高于平衡水平时，工人等待工作岗位的开放时失业的主要原因。</p><h4 id="工会和集体谈判"><a href="#工会和集体谈判" class="headerlink" title="工会和集体谈判"></a>工会和集体谈判</h4><p>工会是一个与雇主就工资、津贴和工作条件进行谈判的工人协会。工会要求的高工资会使得劳动的需求减少，致使未参加工会的人更有可能失业。</p><p>集体谈判：工会与企业就就业挑战达成一致的过程。</p><h4 id="效率工资理论"><a href="#效率工资理论" class="headerlink" title="效率工资理论"></a>效率工资理论</h4><p>效率工资：企业为了提升工人的生产率而支付的高于均衡水平的工资。超出均衡水平的额外工资有希望提高工人的效率，提高产出。大概目的有四：</p><ol><li>工人健康</li><li>工人流动率，增加的工资可以吸引工人在意外情况下留在工作岗位上（减少新工人的培训成本）。</li><li>工人素质，高工资可以吸引有高素质的工人来就业。</li><li>工人努力程度，高工资可以激励工人努力工作以防止被解雇</li></ol><h2 id="第十篇-长期中的货币与物价"><a href="#第十篇-长期中的货币与物价" class="headerlink" title="第十篇 长期中的货币与物价"></a>第十篇 长期中的货币与物价</h2><h3 id="Chapter-29-货币制度"><a href="#Chapter-29-货币制度" class="headerlink" title="Chapter 29 货币制度"></a>Chapter 29 货币制度</h3><p>货币：在物品与服务交换当中卖者通常接受的少数几种资产</p><h4 id="货币的职能"><a href="#货币的职能" class="headerlink" title="货币的职能"></a>货币的职能</h4><p>货币在经济当中有三种职能（这些职能把货币与经济当中的其他资产区分开来）：</p><ol><li>交换媒介，通过货币的转移使得交易能够进行</li><li>计价单位，记录债务和价格的标准</li><li>价值储藏手段：把现在的购买力转变为未来的购买力的一种手段。</li></ol><p>流动性：用来衡量一种资产兑换为经济当中交换媒介的容易程度。货币本身为交换媒介，是最具流动性的。以某种形式持有财富时，必须使每种资产的流动性和作为价值储藏手段的有用性保持平衡。</p><h4 id="货币的种类"><a href="#货币的种类" class="headerlink" title="货币的种类"></a>货币的种类</h4><p>商品货币：当货币本身具有价值时，称为商品货币（如：黄金）当一个经济用黄金作为货币（或是用随时可以兑换为黄金的纸币作为货币），称这个经济是在<em><strong>金本位</strong></em>下运行；另一个例子是战俘营当中的香烟。</p><p>法定货币：没有内在价值的货币，由政府法令所确定的货币</p><p>货币存量：经济中流通的货币量</p><p>货币量的衡量：</p><ul><li>通货：公众手中持有的纸币钞票和铸币</li><li>活期存款（主要指可以开支票的账户）</li><li>储蓄账户</li></ul><h4 id="美国联邦储备体系"><a href="#美国联邦储备体系" class="headerlink" title="美国联邦储备体系"></a>美国联邦储备体系</h4><p>使用法定货币制度的经济，必须有个机构管理这种制度，在美国是联邦储备（美国的中央银行）。联邦储备是中央银行的一个例子，中央银行是为了监管银行体系和调节经济当中的货币量而设计的机构。</p><p>美联储的机构：</p><ol><li>由理事会管理，理事会有7名受到行政任命的理事，任期14年，其中有一名主席。主席人美美联储官员。</li><li>联邦储备体系由华盛顿特区的联邦储备理事会和全国12个地区联邦储备银行组成。地区银行的总裁由每个银行的理事会选择，理事会成员一般来自当地银行和企业界。</li></ol><p>美联储的工作：</p><ol><li>管制银行并确保银行体系的正常运转。主要由地区联邦储备银行负责。</li><li>控制经济中可以得到的货币量，这种货币量称之为货币供给。决策者关于货币供给的政策构成货币政策。在美联储，货币政策是由联邦公开市场委员会（FOMC）制定的。</li></ol><p>联邦公开市场委员会：</p><p>由美联储的7位理事和12个地区银行总裁当中的5位组成。所有的12个地区银行总裁都参与每次会议，但只有5个有投票权。投票权由这12个人轮流享有。通过这个公开市场委员会的决策，美联储有权增加或者减少经济中的美元数量。改变货币供给的主要工具是公开市场操作——买卖美国政府债券。增加货币供给时，美联储在债券市场上购买国债，增加美元供给；减少货币供应时，美联储出售自己资产组合当中的政府债券，减少了货币供给。</p><h4 id="银行与货币供给"><a href="#银行与货币供给" class="headerlink" title="银行与货币供给"></a>银行与货币供给</h4><p>准备金：银行得到但是没有贷出去的存款称为 <em><strong>准备金</strong></em> （一般存在美联储的银行账户当中）。</p><p>T型账户：资产负债表 </p><p>通货以活期存款形式存入银行，若全部成为准备金，则对货币供给没有影响。（这种存款通常以准备金的形式存在金库银行当中）</p><p>部分准备金银行：只用一部分存款作为准备金</p><p>准备金率：银行在总存款当中作为准备金持有的比例，这个比例由政府管制和银行政策共同决定。美联储规定了银行必须持有的准备金量的最低水平，称为 <em><strong>法定准备金</strong></em> ，此外银行可以持有高于法定最低量的准备金，称为 <em><strong>超额准备金</strong></em> 。</p><p>当银行只把部分存款作为准备金时，银行就增加了货币供给，使得经济更加具有流通性，但是经济并没有比以前更富有。多出来的这部分货币供给可能继续作为他人的存款存入银行，使得银行能够继续发放贷款，导致货币供给不断地增多。</p><p>货币乘数：银行体系用1美元准备金所产生的货币量成为货币乘数，货币乘数精确地等于准备金率的倒数。经常用于逆向思维，也就是说，一家银行所准备的准备金量限制了它所能吸纳的存款量。(这个货币乘数的意义在于，准备金衡量了全部货币供给的量，如果这些货币供给全部存在银行，就是货币乘数倍的货币量)</p><p>银行资本：银行不仅可以接受存款并且由于准备金和发放贷款，银行也可以发行股票和债券。银行从股票当中得到的资源称为银行资本。银行也可以购买股票和债券。</p><p>更为现实的国民银行是：</p><ol><li>出项（资产）当中包括准备金、发放出的贷款、购买的债券以及股票（合称金融有价证券）</li><li>进项（负债和所有者权益）当中包括：吸纳的存款、发放债券产生的债务、代表所有者权益的资本（出售股票收入）。</li></ol><p>经济当中许多的经营活动依赖杠杆：将借到的货币追加到用于投资的现有资金上。只要是用债务为投资项目筹资，就是在运用杠杆。</p><p>杠杆率（α&gt;1）：银行的总资产与银行资本的比例。当银行的资产发生变化而负债未变化时，资产的增加率（减少率）会放大α倍作用于银行的资本上。当下降比例经放大超过100%后，银行进入破产状态(无法完全偿还债权人和储户)。</p><p>银行管制者要求银行持有一定量的资本，以确保银行能够偿还其 <strong>储户</strong> 的存款,这种资本的最低值称为 <em><strong>资本需要量</strong></em> ，所要求的资本量取决于银行持有的资产的类型。如果银行持有政府债券这类安全资产，管制者所要求的资本就少于银行持有信用贷款这类风险资产时所要求的成本。当银行发现它们的资本不能满足资本需要量时，会出现经济波动。</p><p>银行可能被挤兑，美国联邦政府通过联邦存款保险公司来保证大多数的银行存款的安全，避免发生挤兑。</p><p>例子：2008年，许多银行发现它们的抵押贷款和抵押贷款支持的有价证券出现亏损，导致银行减少贷款，这种现象称为信用危机，进一步的传导导致了经济活动的减少。为了解决这个问题，美国财政部和美联储把数百亿公共资金投入到银行体系当中来增加银行资本量。</p><h4 id="美联储控制货币的工具"><a href="#美联储控制货币的工具" class="headerlink" title="美联储控制货币的工具"></a>美联储控制货币的工具</h4><p>美联储对货币的控制是通过银行体系间接产生的。这些控制工具主要有两类：影响准备金量的和影响准备金率进而影响货币乘数的。</p><p>影响准备金量（实际的货币供给量）：</p><ul><li>公开市场操作：买卖政府债券时，美联储进行了公开市场操作。增加美元供给时，这些货币中的一部分成为通货，另外一部分进入银行。减少时同理。美联储可以在任何一天利用公开市场操作改变货币供给，这是最常用的货币政策工具。</li><li>美联储向银行贷款：银行可以向美联储的贴现窗口借款，并对贷款支付称为<strong>贴现率</strong>的利率。美联储可以通过改变贴现率来控制银行的贷款，进而影响准备金量。在现在的情形下，美联储可以准备一些资金，进行拍卖（短期拍卖工具）。通过这种贷款方式，美联储可以帮助遇到困难的金融机构。</li></ul><p>影响准备金率（影响货币乘数）：</p><ul><li>调整法定准备金量，很少使用并且效果可能不明显。</li><li>支付准备金利息</li></ul><p>控制货币当中的问题：美联储对货币供给的控制并不精确。原因有两个：</p><ol><li>美联储不能控制家庭以银行存款的方式持有的货币量。</li><li>美联储不能控制银行选择的贷款量。</li></ol><p>美联储可以通过频繁地收集存款和准备金的数据，就可以掌握这种变动。</p><p>联邦基金利率：银行相互贷款时收取的短期利率，这种贷款主要是满足准备金的不足，通常只有一夜。实际的联邦基金利率时由银行间贷款市场上的供求决定，但美联储可以用公开市场操作来影响这个市场，但这些公开市场操作同时也会影响货币供应。联邦基金利率的下降意味着货币供给的扩张，而联邦基金利率的上升意味着货币供给的紧缩。</p><h3 id="Chapter-30-货币增长与通货膨胀"><a href="#Chapter-30-货币增长与通货膨胀" class="headerlink" title="Chapter 30 货币增长与通货膨胀"></a>Chapter 30 货币增长与通货膨胀</h3><p>极高的通货膨胀率（每月的通货膨胀率在50%以上）称为超速通货膨胀。</p><p>货币数量论在一定程度上可以解释通货膨胀（温和的和超速的）。</p><h4 id="古典通货膨胀理论"><a href="#古典通货膨胀理论" class="headerlink" title="古典通货膨胀理论"></a>古典通货膨胀理论</h4><p>通货膨胀可以看作是货币价值的下降。</p><p>货币的供给和需求决定了货币的价格。</p><p>货币的供给量由美联储进行控制。货币需求量取决于人们能够从债券当中赚取的利率。</p><p>货币需求量同时还受到了物价水平的影响：当物价水平上升时，人们不得不持有更多的货币来完成自己的购物消费需要。</p><p>在短期内，货币的需求量和供给量的平衡受到利率的影响，而在长期中，物价总水平会调整到使货币需求的等于货币供给的水平。</p><p>货币供给、货币价值货币数量与物价水平的关系图：</p><p>![货币供给、货币价值货币数量与物价水平的关系图](D:\class selection\2020-2021春选课\3-3宏观经济分析\货币供给价值图.png “图”)</p><p>货币注入的影响：货币量增加，货币价值下降，物价水平上升。货币量增加会导致人们的需求增加，从而使价格上升。</p><p>古典二分法：将各种经济变量分为两类，一类是名义变量（按照货币水平衡量），另外一类是真实变量（按照实物单位进行衡量）。</p><p>货币中性：货币供给变动对真实变量的无关性；而事实上，在短期内，货币供给对真实变量是有一定影响的；在长期中货币供给对真实变量没有影响。</p><p>货币流通速度：经济当中普通的一美元在不同的人手中的流动速度。这个速度由名义GDP来定义，速度V=GDP/M。M是指货币量。GDP通常表示为真实GDP（产量）乘以GDP平减指数（物价水平）</p><p>数量方程式：M×V=P×Y</p><p>在许多的情况下，货币的流通速度通常是较为稳定的，变动不大。</p><p>由于Y（产量）只由生产要素供给和技术决定，M的增加只会导致P的增加，也就是导致物价水平的增加。</p><p>通货膨胀税：当政府通过印发货币筹集收入时，可以说是在征收一种通货膨胀税，这种税是较为隐蔽的，是向每一个持有货币的人征收的税。</p><p>费雪效应：名义利率对通货膨胀率所进行的一对一的调整。费雪效应在长期中是成立的，在短期内（当事人来不及反映）是不成立的。</p><h4 id="通货膨胀的成本"><a href="#通货膨胀的成本" class="headerlink" title="通货膨胀的成本"></a>通货膨胀的成本</h4><p>皮鞋成本：减少个体的货币持有量的所付出的时间和便利的成本</p><p>菜单成本：企业改变价格的成本，包括决定新价格的成本、印刷新价格表和目录的成本等待。</p><p>相对价格变动与资源配置不当：当企业定价变动慢于通货膨胀时，消费者的策略也会被扭曲。</p><p>通货膨胀引起的税收扭曲：法律制定者在制定税法时没有考虑到通货膨胀，通货膨胀往往增加了储蓄所赚到的收入的税收负担。主要是由于成本增加而导致的真实利润减少，相对之下税率提高了。利息税也是。通货膨胀倾向于抑制人们的投资意愿。消除这种问题可以通过税制指数化来完成，也就是说，修改税法来考虑到通货膨胀的影响。</p><p>混乱与不方便：通货膨胀使得一个企业无法确定自身是否盈利，是否成功；也会致使金融市场无法区分。</p><p>任意的财富再分配：未预料到的通货膨胀会使得财富在债务人和债权人之间进行再分配。</p><p>一般来说：比较低水平的通货膨胀是稳定的，而高水平的通货膨胀是不稳定的。</p><p>通货膨胀不好，但通货紧缩可能更坏：通货紧缩会抑制人们储蓄投资的意愿，收入减少、失业增加。</p><h2 id="第十一篇-开放经济的宏观经济学"><a href="#第十一篇-开放经济的宏观经济学" class="headerlink" title="第十一篇 开放经济的宏观经济学"></a>第十一篇 开放经济的宏观经济学</h2><h3 id="Chapter-31-开放经济的宏观经济学：基本概念"><a href="#Chapter-31-开放经济的宏观经济学：基本概念" class="headerlink" title="Chapter 31 开放经济的宏观经济学：基本概念"></a>Chapter 31 开放经济的宏观经济学：基本概念</h3><p>一个开放经济以两种方式和其他经济相互交易：</p><ol><li>在世界产品市场上购买并出售物品与服务。</li><li>在世界金融市场上购买并出售股票和债券这类资本资产。</li></ol><p>概念：出口、进口、净出口（又称为贸易余额）</p><p>贸易余额大于0时，称为贸易盈余；等于0时称为贸易平衡；否则称为贸易赤字。</p><p>金融资源的流动：资本净流出：本国居民购买的外国资产减外国人购买的本国资产。</p><p>资本流动有两种形式：</p><ol><li>向国外直接投资（全资？）</li><li>购买国外有价证券</li></ol><p>影响资本净流出的较重要因素：</p><ul><li>国外资产得到的真实利率</li><li>国内资产得到的真实利率</li><li>国外资产面临的可以察觉到的经济和政治风险</li><li>影响国外对国内资产所有权的政府政策</li></ul><p>在考虑通货作为一种资产时，一个经济的净出口等于净资本流出。</p><p>考虑开放经济时：储蓄=国内投资+资本净流出</p><h4 id="国际交易的汇率"><a href="#国际交易的汇率" class="headerlink" title="国际交易的汇率"></a>国际交易的汇率</h4><p>名义汇率：一个人可以用一国通货交换另一国通货的比率</p><p>如果汇率的变动使得1单位的货币能够买到更多的外国通货，则称为该种货币升值，否则为贬值。通常当一种通货升值时，可以说它是 <strong>坚挺</strong> 的，当贬值时，可以说是 <strong>疲软</strong> 的。</p><p>经济学家通常使用许多汇率平均的变动指数来计算整个通货的变化。</p><p>附：欧元区，由欧洲中央银行（ECB）制定货币政策，由来自所有参与国的代表组成。ECB发现欧元，并控制货币供给。共同的通货的一个好处是使贸易更加容易。一个代价是货币政策只能有一种。</p><p>真实汇率：一个人可以用一国的物品与服务交换另一国的物品与服务的比率。真实汇率可以用一单位国内物品的外国物品量来表示。</p><p>真实汇率=（名义汇率×国内价格）/国外价格</p><p>真实的汇率取决于名义汇率和用本国通货衡量的两国物品的价格。真实汇率是一国进出口多少的关键绝对因素。</p><p>一般衡量真实汇率采用的是物价指数而不是个别物品的价格。所以上述公式更换为：</p><p>真实汇率=（本国CPI*汇率）/国外CPI真实汇率下降意味着国内物品便宜了，会导致出口增加、进口减少。</p><h4 id="第一种汇率决定理论：购买力平价"><a href="#第一种汇率决定理论：购买力平价" class="headerlink" title="第一种汇率决定理论：购买力平价"></a>第一种汇率决定理论：购买力平价</h4><p>理论前提：任何一单位通货应该能在所有国家买到等量的物品。一种物品在所有的地方都应该按照同样的价格出售。所有汇率反映了不同国家的用本国货币衡量的物价水平。</p><p>套利：利用不同市场上同一种东西的价格差的过程称为套利。</p><p>该理论可以解释许多长期的趋势，也有许多局限。</p><p>有两个原因：</p><ol><li>许多物品并不能容易贸易（主要是各种服务）</li><li>当可贸易物品在不同国家生产时，也并不总能被完全替代。</li></ol><h3 id="Chapter-32-开放经济的宏观经济理论"><a href="#Chapter-32-开放经济的宏观经济理论" class="headerlink" title="Chapter 32 开放经济的宏观经济理论"></a>Chapter 32 开放经济的宏观经济理论</h3><p>开放经济当中研究两个市场：可贷资金市场（国内的储蓄和投资，以及国外可贷资金的流动）、外汇市场</p><p>可贷资金市场：国民储蓄（国内可贷资金）=国内投资+资本净流出，资本净流出取决于国内的投资和国民储蓄，取决于国内真实利率。</p><p>外汇市场：资本净流出（本国在国外的资本以及国内的外汇储备）=净出口；这个恒等式代表了外汇市场上的双方。资本净流出是本国的购买量，本国货币的供给量，净出口是外国的购买量，本国货币的需求量。</p><p>使外汇市场供求平衡的价格是真实汇率。本国真实汇率上升，说明本国物品相对价格升高，本国出口量减少，本国货币需求量减少。</p><p>在外汇市场的供给曲线上，供给量不受汇率变化影响，需求受到汇率变化影响。</p><h4 id="政策和事件如何影响开放经济（通过分析这些对曲线的影响来预测结果）"><a href="#政策和事件如何影响开放经济（通过分析这些对曲线的影响来预测结果）" class="headerlink" title="政策和事件如何影响开放经济（通过分析这些对曲线的影响来预测结果）"></a>政策和事件如何影响开放经济（通过分析这些对曲线的影响来预测结果）</h4><p>政府预算赤字：减少了公共储蓄，可贷资金减少，资本净流出减少，本国货币供给减少，汇率上升。在一定程度上增加了进口，减少了出口，会使得贸易朝着赤字方向移动。</p><p>贸易政策：</p><ol><li>关税：对进口物品征收关税。</li><li>进口配额：对进口数量的限制。</li></ol><p>上述两种政策会导致净出口增大，本国货币的需求增多，汇率上升。接着在一定程度上会抑制出口。</p><p>在当前的简单模型当中，净出口=资本外流=国内储蓄-国内投资，所以，直接的贸易政策对净出口没有影响。但会影响某些行业的具体进出口情况。</p><p>政治不稳定与资本外逃：一国的资产需求大量且突然地减少。</p><h2 id="第十二篇-短期经济波动"><a href="#第十二篇-短期经济波动" class="headerlink" title="第十二篇 短期经济波动"></a>第十二篇 短期经济波动</h2><h3 id="Chapter-33-总需求与总供给"><a href="#Chapter-33-总需求与总供给" class="headerlink" title="Chapter 33 总需求与总供给"></a>Chapter 33 总需求与总供给</h3><p>衰退：真实收入下降和失业增加的时期，如果比较严重，则称为 <strong>萧条</strong></p><p>目前的目标是解释短期的经济波动，比较常用的是 <strong>总需求与总供给模型</strong></p><p>模型的两个部分：总需求曲线 总供给曲线</p><h4 id="关于经济波动的三个事实"><a href="#关于经济波动的三个事实" class="headerlink" title="关于经济波动的三个事实"></a>关于经济波动的三个事实</h4><ol><li><p>经济波动是无规律的且不可预测的</p><p>这种波动通常被称为<em><strong>经济周期</strong></em>，虽然称之为周期，但是它并没有规律</p></li><li><p>大多数的宏观经济变量同时波动</p><p>它们的波动幅度并不相同</p></li><li><p>随着产量减少，失业增加</p></li></ol><p>古典理论的货币中性以及名义变量可以很好地描述长期世界，但并不能很好地描述短期世界，在短期当中，真实变量与名义变量是高度相关的。</p><p>该模型将注意力集中在两个变量的行为上。第一个是，用真实GDP衡量的经济中物品与服务的产出；第二个变量是，用CPI或GDP平减指数衡量的物价总水平。</p><p>![总需求与总供给](D:\class selection\2020-2021春选课\3-3宏观经济分析\总需求与总供给.png “总需求与总供给”)</p><p>货币的变动会使得总需求曲线移动</p><p>消费增加、投资增加、政府购买增加、净出口增加会使得总需求曲线向右移动</p><p>在长期当中，总供给曲线是垂直的，劳动增加、资本增加、自然资源增加、技术知识进步可以使得长期的总供给曲线右移</p><p>可以用长期的总供给曲线和总需求曲线搭配来预测长期的经济变化</p><p>在短期内，物价水平与产量成正相关的几个原因：</p><ol><li>黏性工资：工资的改变比较缓慢</li><li>黏性价格：价格的变动是比较缓慢的，例如，价格确定以后，物价水平突然上涨，该价格显得便宜，销售量增加，引起企业产量增加</li><li>错觉：当生产者看到自己的产品价格要上升时，会认为自己的需求量增加，于是自发增加产量</li></ol><p>总的来说，预期物价水平下降增加了物品与服务的总供给量，而预期物价的上升会减少服务于物品的总供给量</p><p>劳动增加、资本增加、技术改进、自然资源增加会导致总供给量的增加</p><p>总需求增加时，短时间内产量会增加，物价水平也会增高，增高的物价水平会使得人们要求提高工资，工资缓慢提高后，企业会减少岗位，总供给下降至长期的均衡水平</p><h3 id="Chapter-34-货币政策和财政政策对总需求的影响"><a href="#Chapter-34-货币政策和财政政策对总需求的影响" class="headerlink" title="Chapter 34 货币政策和财政政策对总需求的影响"></a>Chapter 34 货币政策和财政政策对总需求的影响</h3><h4 id="流动性（指手中现金需求量）偏好理论："><a href="#流动性（指手中现金需求量）偏好理论：" class="headerlink" title="流动性（指手中现金需求量）偏好理论："></a>流动性（指手中现金需求量）偏好理论：</h4><ol><li><p>经济当中的货币量固定在美联储所设定的水平上，并不取决于利率，即货币供给在改变政策之前是一定的</p></li><li><p>利率是持有货币的机会成本，利率增加会减少货币的需求量</p><p>![“曲线”](D:\class selection\2020-2021春选课\3-3宏观经济分析\短期内货币市场与总需求曲线.png)</p></li></ol><p>物价上升时，人们不得不持有较多的现金，货币需求曲线右移，利率上升，导致投资难度加大，总需求减少，同时总产量下降</p><p>**货币影响经济主要是通过影响总需求 **</p><h4 id="总需求的变化的一个原因是货币政策："><a href="#总需求的变化的一个原因是货币政策：" class="headerlink" title="总需求的变化的一个原因是货币政策："></a>总需求的变化的一个原因是货币政策：</h4><p>货币供给增多时，物价不变，利率就会下降，投资难度减小，总需求增加，物价短暂上升且产量增加，工资随后增加，企业成本增加，产量减少，总供给左移，恢复至长期产量。总的结果是物价上升。</p><p>量化宽松：美联储购买抵押贷款和公司债券，使得银行拥有更多的存款准备金</p><p>高涨的股市会让家庭变得富有，刺激企业发售新股，刺激了投资支出，因而扩大了物品与服务的总需求。</p><p>央行的目标之一就是稳定总需求，这就意味着产量和物价水平的稳定</p><p>央行相对于股市：股市下跌时，总需求会下降，为了稳定总需求，央行会增加货币供给，利率下降，产业投资增加，需求增加，意味着利润增加，下跌的股市有可能涨回</p><h4 id="财政政策对总需求的影响："><a href="#财政政策对总需求的影响：" class="headerlink" title="财政政策对总需求的影响："></a>财政政策对总需求的影响：</h4><p>财政政策：政府决策者对政府支出和税收水平的确定。</p><ul><li>改变货币供给或税收水平会通过影响家庭或企业的支出决策间接地使总需求曲线移动</li><li>改变政府购买时直接使总需求移动</li></ul><p>政府购买的影响受到乘数效应和挤出效应的影响</p><h5 id="乘数效应"><a href="#乘数效应" class="headerlink" title="乘数效应"></a>乘数效应</h5><p>政府的购买使得企业利润增加、工人得到工资，这部分货币会增加企业和工人对其他商品和服务的需求</p><p>乘数效应的具体值可以根据<strong>边际消费倾向（MPC）</strong>计算出来</p><p>边际消费倾向：家庭额外收入当中用于消费而不用于储蓄的比例</p><p>经过无限次边际消费倾向的削减迭代，可得乘数的值为1/（1-MPC）</p><p>乘数效应适用于任何可以改变GDP的场景，具体表现为：总需求的部分减少在消费的循环中被乘数效应放大，以至于实际的减少大于该部分</p><h5 id="挤出效应"><a href="#挤出效应" class="headerlink" title="挤出效应"></a>挤出效应</h5><p>扩张性财政政策引起利率上升，从而抑制了投资支出时引起的总需求的增加。</p><p>扩张性的财政政策增加了总需求，导致消费增加，家庭需要持有更多的流动性的货币来满足消费需求，这就导致了利率的上升，减少了投资的增加。</p><h5 id="税收变动"><a href="#税收变动" class="headerlink" title="税收变动"></a>税收变动</h5><p>增税会抑制消费支出，减税会增加消费支出</p><p>税收变动引起的总需求的变化也受到乘数效应和挤出效应的影响，税收变动的影响还与家庭对税收变化的预期有关。家庭对税收的预期越长，影响越大。</p><h4 id="运用政策来稳定经济"><a href="#运用政策来稳定经济" class="headerlink" title="运用政策来稳定经济"></a>运用政策来稳定经济</h4><ol><li>支持积极稳定政策论</li><li>反对积极稳定政策论（各种政策生效有时滞性）</li><li>自动稳定器<ol><li>税制：</li><li>政府支出</li></ol></li></ol><h3 id="Chapter-35-通货膨胀与失业之间的短期权衡取舍"><a href="#Chapter-35-通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="Chapter 35 通货膨胀与失业之间的短期权衡取舍"></a>Chapter 35 通货膨胀与失业之间的短期权衡取舍</h3><p>某个痛苦指数：通货膨胀率+失业率</p><p>在长期当中，通货膨胀取决于中央银行控制的货币的增长；自然失业率取决于劳动市场的特点。通货膨胀与失业率基本毫不相干。</p><p>在短期当中，两者紧密联系。</p><h4 id="菲利普斯曲线"><a href="#菲利普斯曲线" class="headerlink" title="菲利普斯曲线"></a>菲利普斯曲线</h4><p>通货膨胀率与失业呈现负相关，但这仅仅只在短期内成立。</p><p>自然失业率并不受到央行货币政策的影响，这也是“自然”本身的含义。自然失业率的降低会提高相同条件下的产量。自然失业率会受到政府其他政策，像是最低工资法等的影响。</p><h5 id="短期菲利普斯曲线"><a href="#短期菲利普斯曲线" class="headerlink" title="短期菲利普斯曲线"></a>短期菲利普斯曲线</h5><p>失业率=自然失业率-a（实际通货膨胀-预期通货膨胀）</p><p>当受到总供给减少的冲击时，在滞涨的影响下，高通货膨胀和高失业率并存</p><p>牺牲率：在通货膨胀减少一个百分点的过程当中每年产量损失的百分点数。牺牲率一般估算为5</p><p>理性预期：人们根据政府的言论做出的对预期的调整。</p><p>在理性预期下，牺牲率会减小，在极端情况下，以至于没有任何牺牲。</p><h2 id="第十三篇-最后的思考"><a href="#第十三篇-最后的思考" class="headerlink" title="第十三篇 最后的思考"></a>第十三篇 最后的思考</h2><h3 id="Chapter-36-宏观经济政策的六个争论问题"><a href="#Chapter-36-宏观经济政策的六个争论问题" class="headerlink" title="Chapter 36 宏观经济政策的六个争论问题"></a>Chapter 36 宏观经济政策的六个争论问题</h3><h4 id="货币政策与财政政策决策者应该试图稳定经济吗？"><a href="#货币政策与财政政策决策者应该试图稳定经济吗？" class="headerlink" title="货币政策与财政政策决策者应该试图稳定经济吗？"></a>货币政策与财政政策决策者应该试图稳定经济吗？</h4><p>正：保持稳定可以减少不必要的损失</p><p>反：财政政策和货币政策都具有时滞</p><h4 id="政府反衰退应该增加支出还是减税"><a href="#政府反衰退应该增加支出还是减税" class="headerlink" title="政府反衰退应该增加支出还是减税"></a>政府反衰退应该增加支出还是减税</h4><p>正（增加支出）：终结衰退应该提振总需求，财政政策的好处在于，当美联储把利率降低到几乎为零（货币政策已经到达极限）的时候，还可以继续发挥作用。政府的支出增加100%提高了总需求，而为家庭减税，家庭会有一部分减下的税款进入储蓄，总需求提升不明显。一般增加的支出有三类：</p><ul><li>现用现建的基础设施，公路桥梁</li><li>对地方财政的援助，减少公职人员的裁减</li><li>通过失业保障对失业者的补贴</li></ul><p>反（政府应该减税来反衰退）：减税对总供给和总需求都有重要的影响，政府减低边际税率（税收导数）时，工人们可以留下收入中的更大一部分，结果就可以激励失业者去找工作；其次衰退期间的政府支出可能导致政府借债，引起未来的高税收，而且大量的政府支出项目需要长时间的评定和审核，实施过程也比较缓慢。</p><h4 id="货币政策应该按规则制定还是根据已知情况自由抉择"><a href="#货币政策应该按规则制定还是根据已知情况自由抉择" class="headerlink" title="货币政策应该按规则制定还是根据已知情况自由抉择"></a>货币政策应该按规则制定还是根据已知情况自由抉择</h4><p>正（应该按规则制定）：自由抉择带来两个问题：对能力不足以及滥用权力没有限制（可能会使得央行决策者使用政策干预政治治理）；会引起高于合意的通货膨胀水平（影响人们的通货膨胀预期水平）。</p><p>反（货币政策不应该按规则制定）：相机抉择最大的有点是灵活性，可以快速地应对各种危急情况。</p><h4 id="中央银行应该把零通货膨胀作为目标吗？"><a href="#中央银行应该把零通货膨胀作为目标吗？" class="headerlink" title="中央银行应该把零通货膨胀作为目标吗？"></a>中央银行应该把零通货膨胀作为目标吗？</h4><p>正：通货膨胀有着较高的成本，且通货膨胀和失业率之间的取舍在长期中不存在。</p><p>反：零通货膨胀地好处有限，实现它的成本很高。牺牲率带来的产量和收入的减少成本很高。而衰退的成本并不是平均分摊在每一个人身上，技术和经验比较确实的工人最易受到伤害。</p><h4 id="政府应该平衡其预算吗？"><a href="#政府应该平衡其预算吗？" class="headerlink" title="政府应该平衡其预算吗？"></a>政府应该平衡其预算吗？</h4><p>正：赤字会给后代带来债务和高税收，降低生活水平和收入；财政赤字要求政府发行债券，吸纳公共储蓄，这就提高了利率，减少了投资，一定程度上抑制了GDP增长。</p><p>反：为了平衡预算而带来的对其他必要支出削减是危险的，只要债务的增长慢于国民收入的增长，那就是没有问题的。</p><h4 id="应该为了鼓励储蓄而修改税法吗？"><a href="#应该为了鼓励储蓄而修改税法吗？" class="headerlink" title="应该为了鼓励储蓄而修改税法吗？"></a>应该为了鼓励储蓄而修改税法吗？</h4><p>正：鼓励储蓄可以加快经济增长</p><p>反：必须保证公平地分配税收负担</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很少有什么政策只有好处而没有代价！</p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> macro economics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP笔记（2）</title>
      <link href="2021/05/17/oop_note2/"/>
      <url>2021/05/17/oop_note2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>变长字符串 </p><pre><code class="c++">vector&lt;char&gt;//并不好用</code></pre><p>STL中有更方便的string类型</p><pre><code class="c++">//构造string s1;string s2(s1,8,3) //从s1截取，第8位开始，截取3位string s1(10,&quot;x&quot;) //把x复制10次//可以像vector一样使用//常用函数cin&gt;&gt;first;getline(cin,second,&#39;/&#39;);//读入，分隔符为&#39;/&#39;string fullname = firstname + &quot; &quot; + lastname;//拼接,尽量换成+=(&quot;alice&quot;&lt;&quot;bob&quot;)//字符串可以直接比较，按照字典序进行比较，Trueto_string;//其他类型换成字符串stoi();//用来把字符串转换为intstod();//用来把字符串转换为double</code></pre><h2 id="输出输出流"><a href="#输出输出流" class="headerlink" title="输出输出流"></a>输出输出流</h2><h3 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h3><p>iostream是一个类</p><p>具体继承关系为:</p><p><img src="https://i.loli.net/2021/05/17/PbeT4OCYf5wszBm.png" alt="iostream.png"></p><p>箭头指向父类（上图缺少由iostream指向istream和ostream的箭头），cin,cout为对象</p><p>统一了输出接口，改善了C中输出方式的混乱</p><pre><code class="c++">#include &lt;iomanip&gt;cout&lt;&lt;fixed&lt;&lt;2800;//输出固定位数浮点数cout&lt;&lt;scientific&lt;&lt;2018.0;//科学输入法cout&lt;&lt;defaultfloat;//还原默认输出格式，每次用完特殊参数要还原cout&lt;&lt;setprecision(2)&lt;&lt;3.1415;//设置精度为两位，输出3.1cout&lt;&lt;oct&lt;&lt;12&lt;&lt;hex&lt;&lt;12;//输出八进制，十六进制cout&lt;&lt;dec;//还原10进制cout&lt;&lt;setw(3)&lt;&lt;setfill(&#39;*&#39;)&lt;&lt;5;//设置对齐长度，对齐字符为*, **5</code></pre><p>流操纵算子可以自己定义类和输入输出操作，再更改输入输出类可以实现特定操作；</p><p>endl是一个函数，输出\n，并且清空缓存区。</p><p>流运算符的重载要返回指针，避免复制，仅仅使用cout一个全局对象。</p><p>只使用一个对象，减少复制开销，一个对象对于一个标准输出；</p><h3 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h3><p>功能是从文件中读取数据（是一个类，各个输入输出是局部对象）</p><pre><code class="c++">//打开、关闭文件ifstream ifs(&quot;input.txt&quot;);ifstream ifs(&quot;binary.bin&quot;,ifstrea,::binary);//以二进制形式打开文件ifstream ifs;ifs.open(&quot;input.txt&quot;);ifs.close;//关闭文件</code></pre><pre><code class="c++">//其他操作(ifstream是istream的子类)getline(cin,str);get();//读取一个字符ignore(int n=1;int delim=EOF);//丢弃n个字符或者遇到分隔符peek();outback();unget();...</code></pre><h3 id="字符串输入输出流"><a href="#字符串输入输出流" class="headerlink" title="字符串输入输出流"></a>字符串输入输出流</h3><p>一般用于程序内部的字符串操作</p><pre><code class="c++">stringstream ss;//构造ss&lt;&lt;&quot;10&quot;;ss&lt;&lt;&quot;12  21&quot;;int a,b;ss&gt;&gt;a&gt;&gt;b;//a=1212 b=21//可以连接字符串，可以转换为其他类型的数据，配合流操作算子，可以达到格式化输出效果</code></pre><p>stringstream内维护了一个buffer</p><pre><code class="c++">stringstream ss;ss.str();//获取buffer//类型转换，使用模板实现</code></pre><h3 id="关于输入输出"><a href="#关于输入输出" class="headerlink" title="关于输入输出"></a>关于输入输出</h3><p>程序分为两部分：</p><ul><li>程序的算法本身</li><li>输入输出的对象</li></ul><p>数据从算法到对象为输出，从对象到算法为输入，箭头指向数据进入的方向；</p><pre><code class="c++">cin&gt;&gt;a;cout&lt;&lt;a;</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>正则表达式：由字母和符号组成的特殊文本，搜索文本时定义的一种规则</p><p>使用正则表达式表示规则，例如：只能包含小写字母、数字、下划线和连字符，并且限制用户名长度在3~15个字符之间</p><pre><code class="c++">^[a-z0-9_]&#123;3,15&#125;$//^开始标记//[a-z0-9_]字母数字下划线连字符//&#123;3.15&#125;字符长度//$结束标记</code></pre><p>正则表达式的三种模式：</p><ul><li>匹配：判断是否满足条件</li><li>搜索：符合正则表达式的子串</li><li>按规则替换字符串的子串</li></ul><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><ul><li>字符代表本身</li><li>转译字符，使用\转译，\使用\\来转译</li><li>特殊匹配字符<ul><li>^代表字符串开头，$代表字符串结尾</li><li>如：^\只能匹配到以制表符开头的内容</li><li>如：^bucket$只能匹配到只含bucket的内容</li></ul></li></ul><h3 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h3><ul><li>单个字符<ul><li>[asd] 只能是asd</li><li>[a-z] 单个小写字母</li><li>[0-9]单个数字</li></ul></li><li>范围取反<ul><li>[^a-z]不是小写字母</li></ul></li><li>连用<ul><li>[a-z][0-9]</li><li>[a-z]ht普配小写字母和ht</li></ul></li><li>特殊字符</li><li>重复模式<ul><li>{n,m}前面的内容出现n~m次，仅仅对前面一位有效</li></ul></li><li>或连接符‘|’</li><li>（）改变优先级</li></ul><h3 id="C-中使用"><a href="#C-中使用" class="headerlink" title="C++中使用"></a>C++中使用</h3><p>&lt;regex&gt;库</p><pre><code class="c++">regex re(&quot;^[1-9][0-9]&#123;10&#125;$&quot;);//匹配11位数//匹配string s(&quot;awd&quot;);regex e(&quot;a[a-z]&#123;2&#125;&quot;);if(regex_match(s,e))&#123;    cout&lt;&lt;matched;&#125;</code></pre><p>原生字符串：取消转译，保留字面值</p><pre><code class="c++">&quot;\\d+&quot; = R&quot;(\d+)&quot; = \d+ string str=R&quot;(hello world);//str = &quot;hello\nworld&quot;;</code></pre><p>匹配和捕获：使用()进行标识，每个被标识的内容被称为分组</p><pre><code class="c++">string s(&quot;version10&quot;);regex e(R&quot;(version(\d+))&quot;);smatch sm;if(regex_match(s,sm,e))&#123;    cout&lt;&lt;sm.size()&lt;&lt;endl;    for(int i=0;i&lt;sm.size();i++)&#123;        cout&lt;&lt;sm[i]&lt;&lt;endl;    &#125;&#125;</code></pre><p>会输出</p><pre><code>2version1010</code></pre><p>分组当中，0是字符串本身</p><p>搜索：</p><pre><code class="c++">string s(&quot;this subject has a submarine&quot;);regex e(R“((sub)([\S]*))”); smatch sm;while(regex_search(s,sm,e))&#123;    for (unsigned i=0; i&lt;sm.size(); ++i)        cout &lt;&lt; &quot;[&quot; &lt;&lt; sm[i] &lt;&lt; &quot;] &quot;;    cout &lt;&lt; endl;    s = sm.suffix().str();&#125;return 0;</code></pre><p>输出是</p><pre><code class="c++">[subject] [sub] [ject] [submarine] [sub] [marine]</code></pre><p>每次搜索只会保存第一个匹配的子串</p><p>替换：</p><pre><code class="c++">regex_replace(s,re,s1);//替换s中的所有匹配re的子串并且换成s1//s1可以是基本文本，也可以是一些特殊符号，代表分组//$&amp;代表当前串，$1,$2分别代表第一个、第二个子串</code></pre>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用MarkDown书写博客</title>
      <link href="2021/05/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MarkDown%E4%B9%A6%E5%86%99%E5%8D%9A%E5%AE%A2%20-%20%E5%8D%9A%E5%AE%A2%E7%89%88/"/>
      <url>2021/05/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MarkDown%E4%B9%A6%E5%86%99%E5%8D%9A%E5%AE%A2%20-%20%E5%8D%9A%E5%AE%A2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用MarkDown书写博客"><a href="#如何使用MarkDown书写博客" class="headerlink" title="如何使用MarkDown书写博客"></a>如何使用MarkDown书写博客</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>到目前为止，计04班的设备采购工作已经完成，基础的博客网页（ <a href="http://www.thucs04.cn/">www.thucs04.cn</a> ）也已经搭建完成，班级博客将是以后班级形象展示的重要阵地。</p><p>那班级博客上都有什么呢？这就需要大家来贡献自己的力量，书写一些博文，然后经过Github进行上传，充实我们的班级博客。</p><p>为了方便博客的维护，以及减少书写HTML的麻烦，经主要技术人员研究决定，让大家使用MarkDown来书写博文，主题、内容不限。</p><p>那么，什么是MarkDown呢？确切地来说，MarkDown是一种格式，就像是Word文档里可以调整字体的风格、字号，可以加粗文字等，Markdown也是用来进行这些操作的一种语言规范，例如本篇教程就是使用这种规范来书写的。但与Word不同的是，Markdown没有十分方便的GUI（图像界面），需要我们书写一些简单的代码来对这些文字进行格式的设定。</p><h3 id="2-MarkDown的书写平台"><a href="#2-MarkDown的书写平台" class="headerlink" title="2. MarkDown的书写平台"></a>2. MarkDown的书写平台</h3><p>就像是我们写C++的代码会放在VScode 上一样，书写Markdown也有这样的平台，在这种平台上书写，可以方便地让我们看到代码的效果。</p><p>下面推荐两种书写Markdown的平台</p><ul><li><p>VS code</p></li><li><p>typora</p></li></ul><h4 id="2-1-VS-code-书写Markdown-方式"><a href="#2-1-VS-code-书写Markdown-方式" class="headerlink" title="2.1 VS code 书写Markdown 方式"></a>2.1 VS code 书写Markdown 方式</h4><ol><li> 安装vscode，这就足够了，不需要在vscode中安装其他插件</li><li>在vscode新建一个文件，后缀为 .md  例如：test1.md</li><li>右键点击上方 test1.md的标签，选择打开预览，就可以在预览当中看到自己书写的MarkDown代码的效果。</li><li>完成上述工作之后，你就可以在test1.md文件中<del>快乐地</del>书写博文和代码了（如何书写见下方语法教程）</li></ol><img src="https://i.loli.net/2021/05/09/8TfaBZdCFWbkAcD.png" alt="操作图示"  /><h4 id="2-2-typora书写Markdown-方式"><a href="#2-2-typora书写Markdown-方式" class="headerlink" title="2.2 typora书写Markdown 方式"></a>2.2 typora书写Markdown 方式</h4><ol><li>安装typora，网址：<a href="https://typora.io/">https://typora.io/</a>  ，往下翻，可以看到右上角Download选项，点击跳转到下载页面，根据电脑操作系统的版本下载对应的安装包</li><li>安装typora（无需打开这个软件）</li><li>在桌面（或其他位置）上新建一个文件，后缀为.md，以test.md为例</li><li>打开这个文件（选择打开方式为typora），之后你就可以在test.md文件中<del>快乐地</del>书写博文和代码了</li></ol><img src="https://i.loli.net/2021/05/09/nCNAxTJZuqabl4V.png" alt="typora版.png"  /><h3 id="3-Markdown基本使用"><a href="#3-Markdown基本使用" class="headerlink" title="3. Markdown基本使用"></a>3. Markdown基本使用</h3><p><strong>在写博文时，你只需要正常地输入博客的内容，然后在需要的格式处加上MarkDown的语法即可</strong></p><p>如下例（左侧为代码和文本，右侧为效果图）</p><p><img src="https://i.loli.net/2021/05/09/6ypgriUdthWH7Nq.png" alt="书写演示.png"></p><p>这里强烈推荐使用typora，它可以即时地看到效果，不需要打开预览图</p><p>Markdown的具体语法可以在网上查到，推荐一个网站：<a href="https://www.jianshu.com/p/191d1e21f7ed/">Markdown基本语法 - 简书 (jianshu.com)</a></p><h3 id="4-Markdown的基本语法教程"><a href="#4-Markdown的基本语法教程" class="headerlink" title="4. Markdown的基本语法教程"></a>4. Markdown的基本语法教程</h3><ol><li><p>n个#加上一个空格代表一个n级标题</p><p><img src="https://i.loli.net/2021/05/09/GqoRmiFEkDnfl3C.png" alt="基本使用1.png"></p><p><img src="https://i.loli.net/2021/05/09/y7QZD42mA1tHcKn.png" alt="基本使用2.png"></p></li><li><p>一对*括起来表示斜体；两对表示加粗；三对表示斜体加加粗</p><p><img src="https://i.loli.net/2021/05/09/vagwUxXlNIO49Dr.png" alt="基本使用3.png"></p><p><img src="https://i.loli.net/2021/05/09/HLy5mDAivb7jtRO.png" alt="基本使用4.png"></p></li><li><p>1、2、3、4等编号会自动延续，生成有序列表</p><p><img src="https://i.loli.net/2021/05/09/wybZBPEjp1o5SVR.png" alt="基本使用5.png"></p><p><img src="https://i.loli.net/2021/05/09/gbEdm3RhncS5jMo.png" alt="基本使用6.png"></p></li><li><p>三个或以上小短线 — 在单行输入将会作为分割线</p><p><img src="https://i.loli.net/2021/05/09/16VqZWt7DSLgdOK.png" alt="基本使用7.png"></p><p><img src="https://i.loli.net/2021/05/09/m1juBy7MObsXo42.png" alt="基本使用8.png"></p></li><li><p>+，-，*加上空格将会生成无序列表；其可进行分级；在无序列表中shift+tab可回退至无序表的上一级</p><p><img src="https://i.loli.net/2021/05/09/GYwbNknClS9UKJa.png" alt="基本使用9.png"></p><p><img src="https://i.loli.net/2021/05/09/7HGn21NarhXBUAR.png" alt="基本使用10.png"></p></li><li><p>用n个&gt;符号之后加空格可以表示n级引用，可无限嵌套</p><p><img src="https://i.loli.net/2021/05/09/ZB8YjtXrCwLFyzM.png" alt="基本使用11.png"></p><p><img src="https://i.loli.net/2021/05/09/bBwpkNqtL7fiuZD.png" alt="基本使用12.png"></p></li><li><p>连续输入三个`可调用代码块</p><p><img src="https://i.loli.net/2021/05/09/hawdrX9oUBEqJDT.png" alt="基本使用13.png"></p><p><img src="https://i.loli.net/2021/05/09/tz53jiuWyhDg7vc.png" alt="基本使用14.png"></p></li><li><p>两对~中内容表示加上删除线</p><p><img src="https://i.loli.net/2021/05/09/agUVmMuLK4dHntp.png" alt="基本使用15.png"></p><p><img src="https://i.loli.net/2021/05/09/wOu4AWe6a2ojULY.png" alt="基本使用16.png"></p></li><li><p>用短竖线 |内容|内容| 的方式可以创建表格，创建完后可自行调整大小</p><p><img src="https://i.loli.net/2021/05/09/vNkcCuhEUHWFqf2.png" alt="基本使用17.png"></p><p><img src="https://i.loli.net/2021/05/09/PHJcvCAizxfEugS.png" alt="基本使用18.png"></p></li><li><p>[内容]：(网址) 的形式可以实现参数式超链接，不加：也有其他方式</p><p><img src="https://i.loli.net/2021/05/09/XDMStH8uwE7PICR.png" alt="基本使用19.png"></p><p><img src="https://i.loli.net/2021/05/09/QbXC5w9UoaFre6p.png" alt="基本使用20.png"></p><p><img src="https://i.loli.net/2021/05/09/phgSi54vzPGD7b1.png" alt="基本使用21.png"></p><p><img src="https://i.loli.net/2021/05/09/ZuYolXvWhUJgK16.png" alt="基本使用22.png"></p><p><img src="https://i.loli.net/2021/05/09/O7DUpFEMuJseNmL.png" alt="基本使用23.png"></p><p><img src="https://i.loli.net/2021/05/09/uUrsjwNIqiR4Vap.png" alt="基本使用24.png"></p></li><li><p>用！[名字]（路径）的方式可以插入图片（或大部分情况下直接复制即可）</p><p><img src="https://i.loli.net/2021/05/09/296sI1LpbTBRioa.png" alt="基本使用25.png"></p></li></ol><h3 id="5-Markdown书写博客的其他要求"><a href="#5-Markdown书写博客的其他要求" class="headerlink" title="5. Markdown书写博客的其他要求"></a>5. Markdown书写博客的其他要求</h3><p>上面的教程已经教会了大家如何书写Markdown语言规范，而在书写博客时有一个额外的要求：在整篇文档的最上方添加Front-matter</p><p>如何添加Front-matter？</p><p>如图所示，只需在前面添加几行代码：</p><p><img src="https://i.loli.net/2021/05/09/MvAgdCxeQEnoj3S.png" alt="title演示.png"></p><p>如果是typora，输入前面的三个短横线后会自动识别，此时不需要书写最后三个短横线</p><pre><code class="markdown">---title: 这是标题date: 2021/05/08 12:00:00author: 作者名称（建议使用GitHub用户名）categories: 这是分类tag:- demo- test---</code></pre><p>从三条短横线开始，到三条短横线结束，需要填写title、date、author、categories、tag</p><ul><li>title 填写博客的标题，可以中文可以英文</li><li>date 填写博客的建立日期 格式为 YYYY/MM/DD hh:mm:ss</li><li>author 填写作者名称</li><li>categories 这一篇博客的分类，（为了方便管理，目前大家从这四个英文标题当中选填，首字母大写）<ul><li>Introduction  (各类教程、简介)</li><li>Diary （个人生活记录、推送）</li><li>Note （课堂、讲座笔记）</li><li>Discussion （有感而发的讨论）</li></ul></li><li>tag 博客希望的标签，可以添加多个，但是每个短横线之后一定要有<strong>空格</strong></li></ul><p>注意： 每一个参数的冒号后一定要有<strong>空格</strong></p><h3 id="6-关于博客图片的要求"><a href="#6-关于博客图片的要求" class="headerlink" title="6. 关于博客图片的要求"></a>6. 关于博客图片的要求</h3><p>大家在书写博客时可能会有要用到图片的地方，但与基础的图片语法不同的是，博客的图片需要经过处理：</p><ol><li><p>将所用图片储存在本地（你的电脑里）</p></li><li><p>打开网址 <a href="http://www.sm.ms/">www.sm.ms</a></p></li><li><p>将图片拖入框内，选择upload</p></li><li><p>复制下方markdown的语句，粘贴到博客当中即可在博客中插入图片，此外不需要做任何操作</p><p><img src="https://i.loli.net/2021/05/09/PCbwsqE2VS8Hv1K.png" alt="空图.png"></p><p><img src="https://i.loli.net/2021/05/09/UjuxBOtd8wKPim5.png" alt="空图2.png"></p><p><img src="https://i.loli.net/2021/05/09/3doiDKBtmanGelJ.png" alt="空图3.png"></p></li></ol><h2 id="authors-WXY-QC"><a href="#authors-WXY-QC" class="headerlink" title="authors: WXY QC"></a>authors: WXY QC</h2>]]></content>
      
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> introduction </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NieR</title>
      <link href="2021/05/09/fjy/"/>
      <url>2021/05/09/fjy/</url>
      
        <content type="html"><![CDATA[<h1 id="NieR-Automata"><a href="#NieR-Automata" class="headerlink" title="NieR Automata"></a>NieR Automata</h1><ol><li>2B</li><li>9S</li><li>2A</li></ol><p><em>NieR</em> <strong>艾米尔</strong> <em><strong>艾米尔的决意</strong></em></p><hr><h6 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h6><ul><li>获得全部武器</li><li>艾米尔邀请你去他家里玩，<del>他家还蛮大的</del></li></ul><blockquote><p>建议升到99级以后再次挑战</p></blockquote><h5 id="武器列表"><a href="#武器列表" class="headerlink" title="武器列表"></a>武器列表</h5><table><thead><tr><th>name</th><th>type</th></tr></thead><tbody><tr><td><strong>黑之契约</strong></td><td>单手剑</td></tr><tr><td><em><strong>黑之约定</strong></em></td><td>双手剑</td></tr><tr><td><strong>百兽之王</strong></td><td>双手剑</td></tr><tr><td><strong>···</strong></td><td><strong>···</strong></td></tr></tbody></table><p>这里是[<strong>NieR</strong>]</p><p><a href="https://nier.fandom.com/wiki/NIER_Wiki"><strong>NieR Wiki</strong></a>的官网</p>]]></content>
      
      
      
        <tags>
            
            <tag> rpg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的vs code MarkDown 测试</title>
      <link href="2021/05/09/test/"/>
      <url>2021/05/09/test/</url>
      
        <content type="html"><![CDATA[<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> introduction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是标题</title>
      <link href="2021/05/08/test1/"/>
      <url>2021/05/08/test1/</url>
      
        <content type="html"><![CDATA[<h1 id="书写演示"><a href="#书写演示" class="headerlink" title="书写演示"></a>书写演示</h1><h3 id="钱老板NB"><a href="#钱老板NB" class="headerlink" title="钱老板NB"></a>钱老板NB</h3><p><strong>钱老板赛高</strong></p><blockquote><p>钱老板改变了…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 这是分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown博客的基本用法</title>
      <link href="2021/05/08/%E7%94%A8%E6%B3%95/"/>
      <url>2021/05/08/%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="7-1-发布文章"><a href="#7-1-发布文章" class="headerlink" title="# 7.1 发布文章"></a><strong># 7.1 发布文章</strong></h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure><hr><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: my_first_file</span><br><span class="line">date: 2020-12-17 21:20:47</span><br><span class="line">tags: [标签1, 标签2, 标签3]</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><h3 id="7-2-网站设置"><a href="#7-2-网站设置" class="headerlink" title="# 7.2 网站设置"></a><strong># 7.2 网站设置</strong></h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="7-3-更换主题"><a href="#7-3-更换主题" class="headerlink" title="# 7.3 更换主题"></a><strong># 7.3 更换主题</strong></h3><p>在 <a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，比如 <a href="https://link.zhihu.com/?target=http://theme-next.iissnan.com/getting-started.html">NexT</a>，进入网站目录打开 Git Bash Here 下载主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。）</p><h3 id="7-4-常用命令"><a href="#7-4-常用命令" class="headerlink" title="# 7.4 常用命令"></a><strong># 7.4 常用命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> interest </tag>
            
            <tag> include_code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP某节课的笔记</title>
      <link href="2021/05/08/note_of_OOP_from_Teburile/"/>
      <url>2021/05/08/note_of_OOP_from_Teburile/</url>
      
        <content type="html"><![CDATA[<h2 id="模板与STL初步"><a href="#模板与STL初步" class="headerlink" title="模板与STL初步"></a>模板与STL初步</h2><p>类模板：使用参数类型 <typename T> 用类型T来定义模板类</p><pre><code class="c++">template &lt;typename T&gt; class A&#123;    T a;&#125;</code></pre><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>防止名称冲突，引入namespace 关键字</p><pre><code class="c++">namespace A&#123;    int x;    int y;&#125;</code></pre><p>在使用时</p><pre><code class="c++">using namespace A;</code></pre><p>或者是</p><pre><code class="c++">using namespace A::x;</code></pre><h2 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h2><p>STL：Standard Template Library</p><p>包含四个组件：算法，容器，函数，迭代器</p><p>STL的命名空间是std</p><p>一般使用using namespace std::名称</p><p>大型工程当中不推荐引入整个命名空间</p><h3 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h3><p>容器是包含、放置数据的工具，通常为数据结构，包括：</p><ul><li>简单容器</li><li>序列容器</li><li>关系容器</li></ul><h4 id="pair-容器"><a href="#pair-容器" class="headerlink" title="pair 容器"></a>pair 容器</h4><pre><code class="c++">template &lt;class T1,class T2&gt; struct pair&#123;    T1 first;    T2 second;&#125;;std::pair&lt;int,int&gt; t;//或者auto t = std::make_pair(&quot;abc&quot;,7);</code></pre><p>pair 支持小于、等于、大于比较运算符</p><p>先比较第一个元素，再比较第二个元素，要求元素类型支持比较运算符</p><h4 id="tuple-容器"><a href="#tuple-容器" class="headerlink" title="tuple 容器"></a>tuple 容器</h4><p>tuple 是多个元素的pair，要求在使用时就确定内部由多少个元素</p><pre><code class="c++">template&lt;class T1,class T2,class T3&gt; class tuple&#123;    T1 a;    T2 b;    T3 c;&#125;;a=std::get&lt;0&gt;(tuple1);b=std::get&lt;1&gt;(tuple2);//auto t=std::make_tuple(1,2,3);int x,y,z;std::tie(x,y,z)=std::make_tuple(1,2,3);//使用tuple可以使函数返回多个返回值std::tuple&lt;int,double&gt; f(int x)&#123;    return std::make_tuple(x,double(x)/2);&#125;</code></pre><h4 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h4><p>可以自动扩展容量的数组，允许以下标来访问（高速）</p><pre><code class="c++">//创建std::vector&lt;int&gt; x;//当前数组长度int y=x.size();//清空x.clear();//在末尾添加、删除x.push_back(0);x.pop_back();//在中间添加、删除x.insert(x.begin()+1,5);x.erase(x.begin()+1);x.erase(iterator first,iterator last);//删除一段//删除一些元素后，后面的元素依次向前挪动，而迭代器指向的vector的位置不变</code></pre><p>迭代器：一种检查容器内元素并遍历元素的数据类型，使用上类似于指针</p><p>以vector 为例，要求类T有迭代器</p><pre><code class="c++">//定义template&lt;class T,class Allocator = std::allocator&lt;t&gt;&gt;class vector&#123;    class iterator&#123;        ...    &#125;;&#125;;vector&lt;int&gt;::iterator iter;//定义一个迭代器iter=x.begin(); //返回第一个元素的迭代器；iter=x.end();//返回最后一个元素+1位置的迭代器//iterator使用//移动iter +=3;//求元素位置差int dist=iter1-iter2;//应用vector&lt;int&gt; vec;for(vector&lt;int&gt;::iterator it = vec.begin();it != vec.end(); it++)&#123;    ...;&#125;//可以用 auto 来定义it的类型//也可以写成for (auto x:: vec)&#123;    ...;&#125;</code></pre><p>在扩大vector的大小后，可能会使得所有迭代器失效:Push_back 使得vector扩张后，整个vector可能移动位置，扩大所申请的容量。vector 搬迁后，iterator 不变，原来的指向会有问题。 </p><h4 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h4><p>底层是双向链表，要求类T有迭代器</p><pre><code class="c++">//创建template&lt;class T,class Allocator = std::allocator&lt;T&gt;&gt; class list;std::list&lt;int&gt; l;//插入操作l.push_front(1);l.push_back(2);//查询 返回迭代器std::find(l.begin(),l.end(),1);//插入指定位置：l.insert(it,4);</code></pre><p>list不支持下标的随机访问，支持高速在任意位置插入、删除数据，访问主要依赖于迭代器，操作不会导致迭代器失效（除指向被删除元素的迭代器外）</p><h4 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h4><p>不重复元素构成的无序集合</p><p>无序：不保持插入顺序，容器内部排列顺序根据元素大小排列（复杂度为 log n）</p><p>要求类Key 支持比较，有迭代器</p><pre><code class="c++">//定义template&lt;class Key, class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;Key&gt;&gt; class set;//插入s.insert(1);//查询 返回迭代器s.find(2);//删除s.erase(s.find(2));//统计s.count(2);//2的个数，总是0或者1</code></pre><h4 id="map-容器"><a href="#map-容器" class="headerlink" title="map 容器"></a>map 容器</h4><p>map常用作过大的稀疏数组或以字符串为下标的数组</p><p>复杂到为 log n</p><p>要求类Key有比较、迭代器</p><pre><code class="c++">//定义template&lt;class Key,class Compare = std::less&lt;Key&gt;,class Allocator = std::allocator&lt;std::pair&lt;const Key T&gt;&gt;&gt; class map;</code></pre><p>map中的key互不相同，可以通过下标key来访问</p><p>查询：find(key) 统计：count(key)</p><p>删除：使用迭代器 erase；</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my_new_post</title>
      <link href="2021/05/07/my-new-post/"/>
      <url>2021/05/07/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>233333</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2333 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/07/hello-world/"/>
      <url>2021/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
